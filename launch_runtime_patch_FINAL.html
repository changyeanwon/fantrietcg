<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fantrie TCG â€” ëŸ°ì²˜(ìµœì¢…)</title>
  <style>
    :root { --bg1:#5e59d6; --bg2:#6a58d1; }
    html, body { height:100%; margin:0; background:linear-gradient(180deg,var(--bg1),var(--bg2)); font-family:system-ui,Segoe UI,Roboto,Malgun Gothic,sans-serif; color:#eee; }
    #frame { position:fixed; inset:12px; border:0; border-radius:16px; background:#0000; box-shadow:0 10px 40px rgba(0,0,0,.35); width:calc(100% - 24px); height:calc(100% - 24px); }
    #hud { position:fixed; right:12px; bottom:12px; z-index:99999; background:rgba(0,0,0,.85); color:#0f0; padding:6px 8px; border-radius:6px; font:12px/1.4 monospace; max-width:60vw; }
    #toolbar { position:fixed; left:12px; bottom:12px; z-index:99999; display:flex; gap:8px; }
    #toolbar button { background:rgba(0,0,0,.45); color:#fff; border:1px solid rgba(255,255,255,.25); padding:6px 10px; border-radius:8px; font-size:12px; cursor:pointer; }
    #toolbar button:hover { background:rgba(0,0,0,.65); }
    #toolbar { display: none !important; }


  </style>
</head>
<body>

  <!-- ê²Œì„ iframe -->
  <iframe id="frame" title="game"></iframe>

<!-- ê³ ì • ë¡œê·¸ì•„ì›ƒ ë²„íŠ¼ -->
<button id="btn-logout"
  style="position:fixed; top:12px; right:12px; z-index:100000;
         background:rgba(0,0,0,.65); color:#fff; border:1px solid rgba(255,255,255,.25);
         padding:8px 12px; border-radius:10px; font-size:12px; cursor:pointer;
         backdrop-filter:blur(6px); display:none;">
  ë¡œê·¸ì•„ì›ƒ
</button>

  <!-- íˆ´ë°” -->
  <div id="toolbar">
    <button id="btn-main">ë©”ì¸ìœ¼ë¡œ</button>
    <button id="btn-clear-session">ì„¸ì…˜ í† í° ì‚­ì œ</button>
  </div>


  <!-- ì§„ë‹¨ HUD -->
  <div id="hud">loadingâ€¦</div>

  <!-- ===== ì™„ì „íˆ ë‹¨ìˆœí•œ í´ë¼ì´ì–¸íŠ¸ ì „ìš© ë²„ì „ ===== -->
  <script>
// === CardUtils: ì•ˆì „/í˜¸í™˜/ì„±ëŠ¥ í”Œë˜ê·¸ ===
window.CardUtils = window.CardUtils || {};
(function(C){
  // âš™ï¸ í”Œë˜ê·¸: ê¸°ë³¸ì€ ë³´ìˆ˜ì 
  C.FLAGS = {
    USE_MEMO: false,        // ì²˜ìŒì—” OFF â†’ ë¬¸ì œ ì—†ìœ¼ë©´ ON
    STRICT_MASTER: false,   // ìºì‹œ ë¡œë”© ì‹¤íŒ¨ì‹œ throw ì—¬ë¶€ (ê¸°ë³¸ì€ continue)
    MEMO_MAX: 100           // LRU ìš©ëŸ‰ (ì‘ê²Œ ì‹œì‘)
  };

  // ğŸ§  ê°„ë‹¨ LRU (ì „ì—­ ì˜¤ì—¼ ë°©ì§€ìš© ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë‚´ë¶€)
  class SimpleLRU {
    constructor(max=100){ this.max=max; this.m=new Map(); }
    get(k){ if(!this.m.has(k)) return; const v=this.m.get(k); this.m.delete(k); this.m.set(k,v); return v; }
    set(k,v){ if(this.m.has(k)) this.m.delete(k); this.m.set(k,v); if(this.m.size>this.max){ const f=this.m.keys().next().value; this.m.delete(f);} }
    clear(){ this.m.clear(); }
  }
  C.SimpleLRU = C.SimpleLRU || SimpleLRU;
  const MEMO = new C.SimpleLRU(C.FLAGS.MEMO_MAX);

  // ğŸ§© í¬ê·€ë„ ë§¤í•‘/ë°°ìˆ˜(ì—‘ì…€ê°’)
  const S2N = { c:'common', r:'rare', ur:'ultra_rare', e:'epic', g:'gold', sc:'super_common' };
  C.RARITY_MULTIPLIER = C.RARITY_MULTIPLIER || {
    c:{hp:1.00, atk:1.00, def:1.00, spd:1.00},
    r:{hp:1.12, atk:1.12, def:1.12, spd:1.08},
    ur:{hp:1.25, atk:1.25, def:1.25, spd:1.25},
    e:{hp:1.40, atk:1.40, def:1.40, spd:1.40},
    g:{hp:1.57, atk:1.57, def:1.57, spd:1.57},
    sc:{hp:1.80, atk:1.80, def:1.80, spd:1.80}
  };

  // ğŸ¯ í¬ê·€ë„ ì´ë¦„ â†’ ì ‘ë¯¸ì‚¬ ì½”ë“œ ë³€í™˜ ë§µ
  const NAME2SUF = {
    'common':'c', 'rare':'r', 'ultra-rare':'ur', 'ultra_rare':'ur',
    'epic':'e', 'gold':'g', 'super-common':'sc', 'super_common':'sc'
  };

  // ğŸ¯ BíŒ€ ì§€ì‹œì‚¬í•­: í¬ê·€ë„ ë¬¸ìì—´ ì •ê·œí™” í•¨ìˆ˜ ì¶”ê°€
  const normRarity = r => String(r||'common').toLowerCase().replace(/_/g,'-');

  C.applyRarityStats = function(baseStats, sufOrName){
    // ğŸ¯ ë¬¸ìì—´ í¬ê·€ë„ë¥¼ ì ‘ë¯¸ì‚¬ ì½”ë“œë¡œ ë³€í™˜ (ì •ê·œí™” ì ìš©)
    const normalized = normRarity(sufOrName);
    const suf = NAME2SUF[normalized] || sufOrName;
    
    const mul = C.RARITY_MULTIPLIER[suf] || {};
    const out = {...(baseStats||{})};
    for (const k in out) if (typeof out[k]==='number' && typeof mul[k]==='number') out[k] = Math.round(out[k]*mul[k]);
    return out;
  };

  // âœ… ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ ìœ ì§€ìš© ì–‡ì€ íŒŒì„œ
  function parseSlugRaw(input){
    const raw = String(input||'');
    const norm = raw.trim().toLowerCase().replace(/\s+/g,'').replace(/-/g,'_');
    const parts = norm.split('_');
    const res = { base:null, suf:null, rarity:null, isValid:false, norm };
    if (parts.length===2 && parts[0] && parts[1] && ['c','r','ur','e','g','sc'].includes(parts[1])) {
      res.base = parts[0]; res.suf = parts[1]; res.rarity = S2N[res.suf]; res.isValid=true;
    } else {
      res.base = parts[0] || norm || null; // í´ë°±: baseë§Œ ìœ ì§€
    }
    return res;
  }

  // í˜¸í™˜: ê¸°ì¡´ ì½”ë“œê°€ ê¸°ëŒ€í•˜ëŠ” {base,suf,rarity}
  const _oldParse = window.parseSlug || null;
  C.parseSlug = function(input){
    // ë©”ëª¨/ì„±ëŠ¥
    if (C.FLAGS.USE_MEMO) { const hit = MEMO.get(input); if (hit) return hit; }
    const r = parseSlugRaw(input);
    const out = { base:r.base, suf:r.suf, rarity:r.rarity }; // ê¸°ì¡´ê³¼ ë™ì¼
    if (C.FLAGS.USE_MEMO) MEMO.set(input, out);
    return out;
  };

  // í™•ì¥í˜• í•„ìš” ì‹œ ì‚¬ìš©í•˜ëŠ” ë²„ì „ (isValid, norm í¬í•¨)
  C.parseSlugEx = function(input){ return parseSlugRaw(input); };

  // ğŸ’¾ base->master ìºì‹œ (ë‹¨ì¼ ì†ŒìŠ¤)
  C.masterByBase = C.masterByBase || {};
  function sbClient(){
    try { return (typeof getSB==='function'?getSB(): (window.__sb_singleton||window.sb||window.supabase)) || null; }
    catch(_){ return null; }
  }

  C.ensureMasterCache = async function(bases=[], opts={}){
    const cfg = { strict: C.FLAGS.STRICT_MASTER, ...opts };
    const sb = sbClient(); if (!sb) { if (cfg.strict) throw new Error('Supabase missing'); return false; }
    const uniq = [...new Set((bases||[]).filter(Boolean))];
    const req = uniq.filter(b => !C.masterByBase[b]);
    if (!req.length) return true;
    try{
      const { data, error } = await sb.from('card_master')
        .select('slug,name,portrait_url,base_stats,skills,main_job,sub_job')
        .in('slug', req);
      if (error) throw error;
      (data||[]).forEach(m => C.masterByBase[m.slug]=m);
      return true;
    }catch(e){
      console.warn('[ensureMasterCache]', e.message||e);
      if (cfg.strict) throw e;
      return false;
    }
  };

  C.clearClientCaches = function(){
    MEMO.clear();
    C.masterByBase = {};
  };
  window.addEventListener('pagehide', C.clearClientCaches);

})(window.CardUtils);

// ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„±ì„ ìœ„í•œ ë¸Œë¦¿ì§•
window.parseSlug = window.CardUtils.parseSlug;

const DEBUG = new URL(location.href).searchParams.get('debug') === '1';
window.__HUD_LAST = { name: null, score: null };

// ğŸ¯ BíŒ€ ì§€ì‹œì‚¬í•­: Base64 ì¸ë¼ì¸ í´ë°± ì´ë¯¸ì§€
const FALLBACK_IMG = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZpbGw9IiM5OTkiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgdGV4dC1hbmNob3I9Im1pZGRsZSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+';

// ğŸ¯ BíŒ€ ì§€ì‹œì‚¬í•­: no-op í•¨ìˆ˜ ì„ ì–¸
window.ensureCardMasterCache ||= async()=>{};
window.ensureRarityTable ||= async()=>{};

// GPT ìµœì¢… ìˆ˜ì •ì‚¬í•­ ë°˜ì˜ - 5v5 ëŸ°ì²˜ (launcher_5v5_FINAL.html)

(function(){
  const GAME_SRC = 'gpt_game_FIXED_REPAIRED_v2.html';
  
  // === 5v5 ì „íˆ¬ìš© ìƒìˆ˜ ===
  const PARTY_SIZE = 5;
  
  // ğŸ¯ UI í‘œì‹œìš© í¬ê·€ë„ ë³€í™˜ í•¨ìˆ˜ (ë©”ì¸ ìŠ¤ì½”í”„ë¡œ ì´ë™)
  const displayRarity = r => {
    const normRarity = s => String(s||'common').toLowerCase().replace(/_/g,'-');
    const n = normRarity(r);
    return n.charAt(0).toUpperCase() + n.slice(1).replace(/-/g,' ');
  };
  
  // ğŸ¯ ë±ƒì§€ ìƒì„± í—¬í¼ í•¨ìˆ˜ë“¤
  const createRarityBadge = (rarity) => {
    const norm = String(rarity||'common').toLowerCase().replace(/_/g,'-').replace(/\s+/g,'-');
    const display = displayRarity(rarity);
    return `<span class="badge badge-${norm}">${display}</span>`;
  };
  
  const createJobBadge = (job, prefix = '') => {
    if (!job) return '';
    const jobClass = job.toLowerCase().replace(/\s+/g,'-');
    const jobMap = {
      'ë”œëŸ¬': 'dealer',
      'íƒ±ì»¤': 'tanker', 
      'ë¸Œë£¨ì €': 'bruiser',
      'ì„œí¬í„°': 'support',
      'ì»¨íŠ¸ë¡¤ëŸ¬': 'controller'
    };
    const badgeClass = jobMap[job] || jobClass;
    return `<span class="badge badge-${badgeClass}">${prefix}${job}</span>`;
  };
  
  const createAffinityBadge = (affinity) => {
    if (!affinity) return '';
    const affinityClass = affinity.toLowerCase();
    return `<span class="badge badge-${affinityClass}">${affinity}</span>`;
  };
  
  const hud = document.getElementById('hud');
  const log = (...m) => {
    console.log('[LAUNCHER]', ...m);          // ì½˜ì†”ì€ í•­ìƒ
    const hud = document.getElementById('hud'); 
    if (!DEBUG || !hud) return;               // ?debug=1ì¼ ë•Œë§Œ HUD ëˆ„ì 
    hud.innerHTML += (hud.innerHTML ? '<br>' : '') + m.join(' ');
  };

  // ğŸ¯ ì´ë¯¸ì§€ í´ë°± í—¬í¼ (B-3 ìˆ˜ì •ì‚¬í•­)
  function getImageWithFallback(portraitUrl, fallbackText = 'ê¸°ë³¸ ì´ë¯¸ì§€') {
    if (!portraitUrl || portraitUrl.trim() === '') {
      console.log(`[IMAGE FALLBACK] ${fallbackText}: portrait_urlì´ ë¹„ì–´ìˆìŒ â†’ ê¸°ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©`);
      return FALLBACK_IMG;
    }
    
    return portraitUrl;
  }

  const f = document.getElementById('frame');
  f.src = GAME_SRC + '?t=' + Date.now();
  
  // âœ… ê³µí†µ ìœ í‹¸ - HUD ê°±ì‹  (ìƒˆ ê¸°ëŠ¥ ì¶”ê°€)
  function getSB() {
    return window.__sb_singleton || null;
  }
  
  // getSBë¥¼ ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
  window.getSB = getSB;
  
  async function refreshHeaderProfile(retryCount = 0) {
    try {
      const sb = getSB();
      if (!sb) { if (retryCount < 10) { setTimeout(() => refreshHeaderProfile((retryCount||0)+1), 500); } return; }
      const { data:{ session } } = await sb.auth.getSession();
      const uid = session?.user?.id; 
      if (!uid) {
        if (retryCount < 5) {
          setTimeout(() => refreshHeaderProfile(retryCount + 1), 1000);
        }
        return;
      }
      
      // user_profiles ì¡°íšŒ (Supabaseê°€ ìë™ ìƒì„±í•œ player_xxxxx ë‹‰ë„¤ì„ í¬í•¨)
      let { data: prof } = await sb
        .from('user_profiles')
        .select('display_name, pvp_score')
        .eq('user_id', uid)
        .maybeSingle();

      // í”„ë¡œí•„ì´ ì—†ìœ¼ë©´ ëŒ€ê¸° í›„ ì¬ì‹œë„ (auth trigger ì™„ë£Œ ëŒ€ê¸°)
      if (!prof && retryCount < 10) {
        console.log(`[Launcher] Profile not found yet, retrying... (${retryCount + 1}/10)`);
        setTimeout(() => refreshHeaderProfile(retryCount + 1), 1500);
        return;
      }

      // display_nameì´ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš© (player_xxxxx í˜•íƒœ)
      const name = prof?.display_name || 'Player';
      const score = prof?.pvp_score ?? 1000;

      // ê²Œì„ iframe ë‚´ë¶€ì˜ ìš”ì†Œë“¤ ê°±ì‹ 
      const gameDoc = f.contentWindow?.document;
      if (gameDoc) {
        const playerNameEl = gameDoc.getElementById('playerName');
        if (playerNameEl) {
          playerNameEl.textContent = name + ' ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤.';
          console.log('[Launcher] Updated playerName:', name + ' ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤.');
        }
        const playerScoreEl = gameDoc.getElementById('playerScore');
        if (playerScoreEl) {
          playerScoreEl.textContent = String(score);
          console.log('[Launcher] Updated playerScore:', score);
        }
      } else if (retryCount < 10) {
        // iframe ë¬¸ì„œê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì€ ê²½ìš° ì¬ì‹œë„
        setTimeout(() => refreshHeaderProfile(retryCount + 1), 500);
      }
    } catch (e) {
      console.warn('[refreshHeaderProfile]', e);
      if (retryCount < 10) {
        setTimeout(() => refreshHeaderProfile(retryCount + 1), 1500);
      }
    }
  }
  
  // refreshHeaderProfileì„ ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
  window.refreshHeaderProfile = refreshHeaderProfile;
  
  // === 5v5 ìƒ˜í”Œë§ìš© RNG í•¨ìˆ˜ë“¤ ===
  function makeSeedFromString(str){
    // ê°„ë‹¨ í•´ì‹œ â†’ uint32
    let h = 2166136261 >>> 0;
    for (let i=0; i<str.length; i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619) >>> 0;
    }
    return h >>> 0;
  }

  function xorshift32(seed){
    let s = seed >>> 0;
    return function(){
      // 0..1 ì‹¤ìˆ˜
      s ^= s << 13; s ^= s >>> 17; s ^= s << 5;
      return ((s >>> 0) / 0xFFFFFFFF);
    };
  }

  // [ìˆ˜ì •] GPT ê¶Œì¥ ìƒ˜í”ŒëŸ¬ - ì¤‘ë³µ ì—†ì´ kê°œ ì¶”ì¶œ
  function sampleK(arr, k, rng) {
    const pool = [...arr].filter(Boolean);
    const out = [];
    for (let i = 0; i < k && pool.length; i++) {
      const idx = Math.floor(rng() * pool.length);
      out.push(pool[idx]);
      pool.splice(idx, 1);
    }
    return out;
  }
  
  f.addEventListener('load', () => {
    const w = f.contentWindow; 
    if (!w) return;
    const d = w.document;
    
    log('iframe loaded');
    
    // ì´ˆê¸° í”„ë¡œí•„ ë°ì´í„° ë¡œë“œ - ì§€ì—°ëœ ì•ˆì •ì  ë¡œë“œ
   // ì´ˆê¸° í”„ë¡œí•„ ë°ì´í„° ë¡œë“œ - ì§€ì—°ëœ ì•ˆì •ì  ë¡œë“œ
  setTimeout(() => {
    // ëª¨ë“  ë°”ì¸ë”© í”Œë˜ê·¸ ì´ˆê¸°í™”
    d.querySelectorAll('button').forEach(btn => {
      delete btn.__bound;
      delete btn.__gacha_bound;
    });
    
    bindButtons();
    bindGacha();
    enableGachaInGame();
    
   // ì „íˆ¬í•˜ê¸° ë²„íŠ¼ ê°•ì œ í™œì„±í™”
const battleBtn = d.getElementById('battleBtn');
if (battleBtn) {
  battleBtn.disabled = false;
  // onclick ë°”ì¸ë”© ì œê±° - bindButtons()ì—ì„œ ì²˜ë¦¬í•¨
}
    
    // ê°€ì±  ë²„íŠ¼ ê°•ì œ í™œì„±í™”  
    const drawBtn = d.getElementById('drawCardBtn');
    if (drawBtn) {
      drawBtn.disabled = false;
      bindGacha();
    }
    
    refreshHeaderProfile();

// ì„œë²„ ì˜¤í”„ì…‹ ì „ë‹¬
    if (window.__serverOffsetMs !== undefined) {
        f.contentWindow.__serverOffsetMs = window.__serverOffsetMs;
    }

  }, 1000);
  
  // ì¶”ê°€ ë³´ì¥ì„ ìœ„í•œ 2ì°¨ ê°±ì‹ 
  setTimeout(() => {
    refreshHeaderProfile();
  }, 3000);
    
    // ì²« ë¡œê·¸ì¸ ê°ì§€ ë° ì¶”ê°€ ê°±ì‹ 
    setTimeout(async () => {
      try {
        const sb = getSB();
        if (!sb) { setTimeout(() => refreshHeaderProfile(), 500); return; }
        const { data: { session } } = await sb.auth.getSession();
        if (session?.user?.id) {
          const { data: prof } = await sb
            .from('user_profiles')
            .select('display_name')
            .eq('user_id', session.user.id)
            .maybeSingle();
          
          // player_ë¡œ ì‹œì‘í•˜ë©´ ì²« ë¡œê·¸ì¸ìœ¼ë¡œ ê°„ì£¼í•˜ê³  ì¶”ê°€ ê°±ì‹ 
          if (prof?.display_name?.startsWith('player_')) {
            console.log('[Launcher] First login detected, additional refresh...');
            refreshHeaderProfile();
            setTimeout(() => refreshHeaderProfile(), 2000);
            setTimeout(() => refreshHeaderProfile(), 5000);
          }
        }
      } catch (e) {
        console.warn('[First login check]', e);
      }
    }, 4000);
    
    // ğŸ¯ ìŠ¤íƒ€ì¼ ì£¼ì… - ë‚´ ì¹´ë“œ ë³´ê¸° í™”ë©´ì„ ë± ì„¤ì •ê³¼ í†µì¼
    
    
    // ğŸ¯ ê²Œì„ ë°ì´í„° ì´ˆê¸°í™”
    w.playerData = w.playerData || {};
    w.playerData.decks = w.playerData.decks || [[], [], [], []];
    w.currentDeck = w.currentDeck || 0;
    w.selectedCard = null;
    
    // ğŸ¯ í™”ë©´ ì „í™˜ (ë°”ì¸ë”©ë„ í•¨ê»˜)
    w.showScreen = w.showScreen || function(id) {
  try {
    d.querySelectorAll('.screen').forEach(s => s.classList.toggle('active', s.id === id));
    // í™”ë©´ ì „í™˜ ì‹œì—ë§Œ ë°”ì¸ë”© (ì£¼ê¸°ì  ë°”ì¸ë”© ì œê±°)
    setTimeout(() => {
      // ê¸°ì¡´ ë°”ì¸ë”© í”Œë˜ê·¸ ì œê±°
      d.querySelectorAll('button').forEach(btn => {
        delete btn.__bound;
        delete btn.__gacha_bound;
      });
      bindButtons();
      bindGacha();
    }, 500);
  } catch(e) { 
    log('Screen switch error: ' + e.message); 
  }
};
    
    // ğŸ¯ **ë‹¨ì¼ ì—°ì¶œ ì‹œìŠ¤í…œ** (ëŸ°ì²˜ì—ì„œë§Œ ì²˜ë¦¬) - ê²Œì„ ìŠ¤íƒ€ì¼ ì´í™íŠ¸ ì ìš©
    
    
    // ğŸ¯ ê°€ì±  ë²„íŠ¼ (ê°œì„ ëœ ë‹¨ì¼ ë°”ì¸ë”©)
    function bindGacha() {
      const btn = d.getElementById('drawCardBtn') || 
                 [...d.querySelectorAll('button')].find(b => /ì¹´ë“œ.*ë½‘ê¸°|ê°€ì± /i.test(b.textContent||''));
      
      if (!btn || btn.__gacha_bound) return;
      btn.__gacha_bound = true;
      
      // ì™„ì „í•œ ì´ë²¤íŠ¸ êµì²´
      const newBtn = btn.cloneNode(true);
      btn.parentNode?.replaceChild(newBtn, btn);
      
      newBtn.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (newBtn.disabled) return;
        newBtn.disabled = true;
        newBtn.textContent = 'ë½‘ëŠ” ì¤‘...';
        
        try {
          const sb = window.__sb_singleton || window.supabase || window.sb;
          const { data: { session } } = await sb.auth.getSession();
          
          if (!session?.access_token) {
            alert('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
            return;
          }
          
          // 1. ê°€ì±  ì‹¤í–‰
          const res = await fetch('https://ezuvoqehzojiqmzatzbf.supabase.co/functions/v1/draw', {
            headers: { Authorization: 'Bearer ' + session.access_token }
          });
          const result = await res.json();
          
          if (!result.ok) {
            alert('ê°€ì±  ì‹¤íŒ¨: ' + result.error);
            return;
          }
          
          const { card_slug, rarity } = result.result;
          
          // 2. ì¹´ë“œ ì •ë³´ ì¡°íšŒ
          const cardRes = await fetch(`https://ezuvoqehzojiqmzatzbf.supabase.co/rest/v1/card_master?slug=eq.${encodeURIComponent(card_slug)}&select=slug,name,portrait_url,base_stats,skills,main_job,sub_job`, { 
            headers: { 
              'Authorization': 'Bearer ' + session.access_token,
              'apikey': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV6dXZvcWVoem9qaXFtemF0emJmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwMDM4ODQsImV4cCI6MjA3MDU3OTg4NH0.4B33BI-WOgoeQHvQ4XBTNwwCCfvQiuVMWRpnOOOHrjw'
            }
          });
          const cards = await cardRes.json();
          const card = cards?.[0];
          
          if (!card) {
            alert('ì¹´ë“œ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨');
            return;
          }
          
          log(`got: ${card.name} (${rarity})`);
          
          // 3. ğŸ¯ ê²Œì„ íŒŒì¼ë¡œ ì—°ì¶œ ìœ„ì„ (postMessage)
          const iframe = document.getElementById('frame');
          iframe?.contentWindow?.postMessage({ 
            type: 'REVEAL_CARD', 
            payload: { card, rarity } 
          }, '*');
          
          // 4. ì„ íƒ: ì¹´ë“œ ëª©ë¡ ê°±ì‹  ìš”ì²­ (ê²Œì„ íŒŒì¼ í•¨ìˆ˜ê°€ ìˆìœ¼ë©´ í˜¸ì¶œ)
          setTimeout(() => {
            iframe?.contentWindow?.loadOwnedFromServer?.();
          }, 100);

// ê°€ì±  ì¿¨íƒ€ì„ ì‹œì‘
          setTimeout(() => {
            iframe?.contentWindow?.cooldownManager?.startCooldown('draw', new Date().toISOString(), 60);
          }, 200);
          
        } catch (error) {
          console.error('Gacha error:', error);
          alert('ê°€ì±  ì˜¤ë¥˜: ' + error.message);
          // ì¦‰ì‹œ ìƒˆë¡œê³ ì¹¨ìœ¼ë¡œ ë³µêµ¬ ì‹œë„
          loadCards();
        } finally {
          // 5ì´ˆ í›„ ë²„íŠ¼ ì¬í™œì„±í™”
          setTimeout(() => { 
            newBtn.disabled = false;
            newBtn.textContent = 'ì¹´ë“œ ë½‘ê¸°';
          }, 5000);
        }
      });
    }
    
    // ğŸ¯ **ì„œë²„ ê°•ì œ ëª¨ë“œ** - ë± ì €ì¥ (user_card_id ë°©ì‹)
    async function saveDeckToServer(deckIndex, deck) {
    try {
        const sb = window.__sb_singleton || window.supabase || window.sb;
        const { data: { session } } = await sb.auth.getSession();
        
        // ê¸°ì¡´ ë± ì‚­ì œ
        const { error: deleteError } = await sb
            .from('user_decks')
            .delete()
            .eq('user_id', session.user.id)
            .eq('deck_index', deckIndex);
        
        if (deleteError) throw deleteError;
        
        // nullì´ ì•„ë‹Œ ìŠ¬ë¡¯ë§Œ ì €ì¥
        // nullì´ ì•„ë‹Œ ìŠ¬ë¡¯ë§Œ ì €ì¥
const validSlots = [];
for (let i = 0; i < 10; i++) {
    if (deck[i] && deck[i].user_card_id) {
        const rarityMap = {
            'common': 'c',
            'rare': 'r',
            'ultra-rare': 'ur',
            'ultra_rare': 'ur',
            'epic': 'e',
            'gold': 'g',
            'super-common': 'sc',
            'super_common': 'sc'
        };
        
        const slug = deck[i].card_slug || '';
        const rarity = deck[i].rarity || 'common';
        const normalizedRarity = rarity.toLowerCase().replace(/_/g, '-');
        const rarityCode = rarityMap[normalizedRarity] || 'c';
        
        validSlots.push({
            user_id: session.user.id,
            deck_index: deckIndex,
            deck_slot: i,
            user_card_id: deck[i].user_card_id,
            card_slug: `${slug}_${rarityCode}`  // ì´ì œ 's_g' í˜•íƒœë¡œ ì €ì¥ ê°€ëŠ¥
        });
    }
}
        
        if (validSlots.length > 0) {
            const { error: insertError } = await sb
                .from('user_decks')
                .insert(validSlots);
            
            if (insertError) throw insertError;
        }
        
        log(`Deck ${deckIndex} saved: ${validSlots.length} cards`);
        return true;
        
    } catch (error) {
        console.error('Save deck failed:', error);
        throw error;  // ìƒìœ„ë¡œ ì—ëŸ¬ ì „íŒŒ
    }
}
    
    // ë± ë¡œë“œ (ì•ˆì •í™”ëœ ì¿¼ë¦¬)
    async function loadDeckFromServer() {
      try {
        const sb = window.__sb_singleton || window.supabase || window.sb;
        const { data: { session } } = await sb.auth.getSession();
        
        if (!session?.access_token || !session?.user?.id) {
          throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
        }
        
        log('ğŸ“¦ Loading decks from server...');
        
       // âœ… card_master ì •ë³´ë„ í•¨ê»˜ ì¡°íšŒ (ì´ë¯¸ì§€/ì´ë¦„ ë¬¸ì œ í•´ê²°)
        const { data: deckData, error } = await sb
          .from('user_decks')
          .select(`
            deck_index, deck_slot, card_slug, user_card_id,
            user_cards!inner(
              rarity,
              card_master:card_slug (
                slug, name, portrait_url, base_stats, skills,
                main_job, sub_job
              )
            )
          `)
          .eq('user_id', session.user.id)
          .order('deck_index', { ascending: true })
          .order('deck_slot', { ascending: true });        
        if (error) {
          throw new Error(`ë± ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
        }
        
        if (deckData && deckData.length > 0) {
          // ë± ë°ì´í„° ì´ˆê¸°í™”
          w.playerData.decks = [[], [], [], []];
          
          // ì„œë²„ ë°ì´í„°ë¡œ ë± ë³µì› (ì™„ì „í•œ ì¹´ë“œ ì •ë³´ í¬í•¨)
          deckData.forEach(slot => {
            const deckIndex = slot.deck_index || 0;
            if (deckIndex >= 0 && deckIndex < 4) {
                if (!w.playerData.decks[deckIndex]) w.playerData.decks[deckIndex] = [];
                
                // ì¡°ì¸ëœ ì¹´ë“œ ì •ë³´ ì¶”ì¶œ
                const userCard = slot.user_cards;
                const cardMaster = userCard?.card_master;
                
                if (cardMaster) {
                    // ì™„ì „í•œ ì¹´ë“œ ì •ë³´ë¡œ ë± ì•„ì´í…œ ìƒì„±
                    w.playerData.decks[deckIndex][slot.deck_slot] = {
                        user_card_id: slot.user_card_id,
                        card_slug: slot.card_slug.split('_')[0],  // ë² ì´ìŠ¤ ìŠ¬ëŸ¬ê·¸
                        rarity: userCard.rarity || 'common',
                        name: cardMaster.name,
                        portrait_url: cardMaster.portrait_url,
                        base_stats: cardMaster.base_stats,
                        skills: cardMaster.skills,
                        main_job: cardMaster.main_job,
                        sub_job: cardMaster.sub_job
                    };
                } else {
                    // í´ë°±: ê¸°ì¡´ ë°©ì‹
                    const parts = slot.card_slug.split('_');
                    const rarityMap = {
                        'c': 'common', 'r': 'rare', 'ur': 'ultra-rare',
                        'e': 'epic', 'g': 'gold', 'sc': 'super_common'
                    };
                    
                    w.playerData.decks[deckIndex][slot.deck_slot] = {
                        user_card_id: slot.user_card_id,
                        card_slug: parts[0],
                        rarity: rarityMap[parts[1]] || 'common'
                    };
                }
            }
          });          
          // ë°°ì—´ ì •ë¦¬ (undefined ì œê±°)
          w.playerData.decks.forEach(deck=>{for(let i=0;i<10;i++){if(deck[i]===undefined)deck[i]=null;} deck.length=10;});
          
          const deckSizes = w.playerData.decks.map(d => d.length).join(',');
          log(`ë± ë¡œë“œ ì™„ë£Œ: [${deckSizes}]`);
          console.log('[loadDeck] rows:', deckData.length, 'composed:', w.playerData.decks.reduce((a,b)=>a+b.length,0));
          
          // UI ì—…ë°ì´íŠ¸
          refreshDeckUI();
          return true;
        } else {
          log('ğŸ“¦ No deck data on server');
          return false;
        }
        
      } catch (error) {
        console.error('Load deck from server failed:', error);
        log(`ë± ë¡œë“œ ì˜¤ë¥˜: ${error.message}`);
        
        alert(`ë± ë¡œë“œ ì‹¤íŒ¨!\n${error.message}\n\nì„œë²„ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.`);
        return false;
      }
    }
    
    // ğŸ¯ ì¹´ë“œ ëª©ë¡ ë¡œë“œ (PostgREST ì„ë² ë””ë“œ ì¡°ì¸ í™œìš©) - ìˆ˜ì •ëœ ë²„ì „
    async function loadCards() {
      try {
        // ğŸ¯ BíŒ€ ì§€ì‹œì‚¬í•­: ë¹„ë™ê¸° íƒ€ì´ë° ë³´ì¥
        try { if (window.ensureCardMasterCache) await window.ensureCardMasterCache(); } catch (e) { console.warn('ensureCardMasterCache failed', e); }
        try { if (window.ensureRarityTable) await window.ensureRarityTable(); } catch (e) { console.warn('ensureRarityTable failed', e); }
        
        const sb = window.__sb_singleton || window.supabase || window.sb;
        const { data: { session } } = await sb.auth.getSession();
        
        if (!session?.access_token) {
          log('âš ï¸ Not logged in, cannot load cards');
          return;
        }
        
        // ğŸ¯ ë¨¼ì € ì¹´ë“œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜´
        const { data: userCards, error } = await sb
          .from('user_cards')
          .select(`
            id, rarity, obtained_at,
            card_master:card_slug (
              slug, name, portrait_url, base_stats, skills,
              main_job, sub_job
            )
          `)
          .eq('user_id', session.user.id)
          .order('obtained_at', { ascending: false });

        console.log('[TEST] First card skills:', userCards?.[0]?.card_master?.skills);

        if (error) {
          throw new Error(`ì¹´ë“œ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
        }
        
        // ğŸ¯ ì „ì—­ ë³€ìˆ˜ì— ì¹´ë“œ ë°ì´í„° ì €ì¥ (í•„í„°ë§ìš©)
        w.allUserCards = userCards || [];
// O(1) lookup map for user_card_id â†’ userCard
w.userCardById = Object.create(null);
(userCards || []).forEach(uc => { w.userCardById[uc.id] = uc; });

        
        // ğŸ¯ ì¹´ë“œ ìºì‹œ ìƒì„± (ë± UIì—ì„œ slugâ†’ì •ë³´ ë§¤í•‘ìš©)
        w.cardCache = {};
        w.cardBySlug = {};  // âœ… ì¶”ê°€ ì¸ë±ìŠ¤ - slugë¡œ ì§ì ‘ ì ‘ê·¼ìš©
        (userCards || []).forEach(uc => {
          const card = uc.card_master;
          if (card) {
            // ğŸ¯ GPT ì œì•ˆ: base_statsì—ì„œ affinity íŒŒì‹±
            const affinity = card.base_stats?.affinity || null;
            
            // ğŸ¯ slug ë³´ì¥ - ID ì¶”ê°€ë¡œ ìœ ë‹ˆí¬í•˜ê²Œ
            const slugKey = `${uc.id}_${card.slug || uc.card_slug}`;
            
            const cardInfo = {
              name: card.name,
              portrait_url: card.portrait_url,
              base_stats: card.base_stats,
              rarity: uc.rarity,
              main_job: card.main_job,
              sub_job: card.sub_job,
              affinity: affinity,
              skills: card.skills || {}
            };
            
            w.cardCache[slugKey] = cardInfo;
            if (card.slug) w.cardBySlug[card.slug] = cardInfo;  // âœ… slugâ†’info ì§ì ‘ ë§¤í•‘
            console.log(`[Cache] Storing card: ${card.name} (${card.slug}) with image: ${card.portrait_url ? 'YES' : 'NO'}`);
            if (card.skills?.active?.description) {
              console.log(`[SKILL OK] ${card.name}: ${card.skills.active.description.substring(0, 30)}...`);
            } else {
              console.log(`[SKILL MISSING] ${card.name}: No active description`);
            }
          }
        });
        
        // ğŸ¯ ìƒˆë¡œ ì¶”ê°€: í•„í„° ì´ë²¤íŠ¸ ë°”ì¸ë”©
        bindFilterEvents();
        
        // ğŸ¯ ì´ˆê¸° ì¹´ë“œ ëª©ë¡ í‘œì‹œ
        setTimeout(() => filterAndDisplayCards(), 100);
        
        // ë‚´ ì¹´ë“œ ë³´ê¸° í™”ë©´ - ê°œì„ ëœ í¬ë§·
        const cardCollection = d.getElementById('cardCollection');
        if (cardCollection) {
          cardCollection.innerHTML = '';
          (userCards || []).forEach(uc => {
            const card = uc.card_master;
            if (!card) return;
            
            const cardEl = d.createElement('div');
            cardEl.className = 'card';
            
            // ğŸ¯ ì‚¬ìš©ì ìš”ì²­ í¬ë§·ì— ë§ê²Œ ê°œì„  - ì–´ë‘ìš´ í…Œë§ˆ ì ìš©
            const affinity = card.base_stats?.affinity || 'Unknown';
            const mainJob = card.main_job || '';
            const subJob = card.sub_job || '';
            const stats = card.base_stats || {};
            const skills = card.skills || {};
            
            // ìŠ¤í‚¬ ì •ë³´ ì¶”ì¶œ
            const activeSkill = skills.active ? `ì•¡í‹°ë¸Œ: ${skills.active.name || 'ë¯¸ì§€ì˜ ìŠ¤í‚¬'}` : 'ì•¡í‹°ë¸Œ: ì—†ìŒ';
            const passiveSkill = skills.passive ? `íŒ¨ì‹œë¸Œ: ${skills.passive.name || 'ë¯¸ì§€ì˜ ìŠ¤í‚¬'}` : 'íŒ¨ì‹œë¸Œ: ì—†ìŒ';
            
            // í¬ê·€ë„ì— ë”°ë¥¸ í´ë˜ìŠ¤ ì¶”ê°€ - ì •ê·œí™” ì ìš©
            const normRarity = r => String(r||'common').toLowerCase().replace(/_/g,'-').replace(/\s+/g,'-');
            cardEl.classList.add(normRarity(uc.rarity));
            
            // ğŸ¯ ì´ë¯¸ì§€ í´ë°± ì ìš©
            const cardImageSrc = getImageWithFallback(card.portrait_url, `ì»¬ë ‰ì…˜ - ${card.name}`);
            
            cardEl.innerHTML = `
              <div style="border-radius:8px 8px 0 0;overflow:hidden;background:#0a0f22;border-bottom:2px solid #22285a;aspect-ratio:2/3;">
                <img src="${cardImageSrc}" style="width:100%;height:100%;object-fit:cover;display:block" onerror="this.src='${FALLBACK_IMG}';this.onerror=null;">
              </div>
              <div style="padding:12px;background:rgba(10,13,32,0.8);border-radius:0 0 8px 8px;">
                <div style="font-weight:800;color:#fff;margin-bottom:6px;font-size:16px;text-shadow:0 1px 2px rgba(0,0,0,0.5);">${card.name}</div>
                <div style="margin-bottom:6px;">${createRarityBadge(uc.rarity)}</div>
                <div style="margin-bottom:6px;">
                  ${mainJob ? createJobBadge(mainJob) : ''}${subJob ? createJobBadge(subJob) : ''}
                </div>
                <div style="margin-bottom:8px;">${affinity ? createAffinityBadge(affinity) : ''}</div>
                <div style="background:rgba(0,0,0,0.4);padding:8px;border-radius:6px;margin-bottom:6px;">
                  <div style="color:#e9ecff;font-weight:600;margin-bottom:4px;font-size:12px;">
                    HP ${stats.hp??'-'} | ATK ${stats.atk??'-'}
                  </div>
                  <div style="color:#e9ecff;font-weight:600;font-size:12px;">
                    DEF ${stats.def??'-'} | SPD ${stats.spd??'-'}
                  </div>
                </div>
                <div style="background:rgba(0,0,0,0.3);padding:8px;border-radius:6px;">
                  <div style="color:#9aa1c6;font-size:11px;line-height:1.4;">
                    <div style="margin-bottom:3px;color:#cfd5ff;">${activeSkill}</div>
                    <div style="color:#cfd5ff;">${passiveSkill}</div>
                  </div>
                </div>
              </div>
            `;
            cardCollection.appendChild(cardEl);
          });
        }
        
        log(`âœ… loaded ${userCards?.length || 0} cards`);
        console.log('[loadCards] uc:', userCards?.length || 0, 'rendered:', cardCollection?.children?.length || 0);
        
        // ë‚´ ì¹´ë“œ ë³´ê¸° í•„í„° ì´ˆê¸°í™”
        setTimeout(() => initCardFilters(), 500);
        
        // ğŸ¯ ì¹´ë“œ ëª©ë¡ í‘œì‹œ - cardCache í™•ì¸ í›„ ì‹¤í–‰
        if (Object.keys(w.cardCache || {}).length > 0) {
          filterAndDisplayCards();
        } else {
          setTimeout(() => filterAndDisplayCards(), 200);
        }
        
        // ğŸ¯ íƒ€ì´ë° ë³´ì •: ì´ˆê¸° ë¡œë”© ì‹œ ë¹ˆ ëª©ë¡ ë¬¸ì œ í•´ê²°
        setTimeout(() => {
          const ownedList = d.getElementById('ownedList');
          if (ownedList && ownedList.children.length === 0) {
            filterAndDisplayCards();
          }
        }, 150);
        
        // ìºì‹œ ë³´ê°•
        const bases = [...new Set((userCards||[]).map(uc => uc.card_master?.slug).filter(Boolean))];
        await CardUtils.ensureMasterCache(bases).catch(()=>{ /* ê¸°ì¡´ í”Œë¡œìš° ê³„ì† */ });
        
      } catch (error) {
        console.error('Load cards failed:', error);
        log(`âš  Load cards error: ${error.message}`);
        alert(`ì¹´ë“œ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨!\n${error.message}`);
      }
    }
    
    // ì¹´ë“œ í•„í„° ì‹œìŠ¤í…œ
    
    
    // ğŸ¯ ìƒˆë¡œ ì¶”ê°€: í•„í„° ì´ë²¤íŠ¸ ë°”ì¸ë”©
    
    
    // ğŸ¯ ìƒˆë¡œ ì¶”ê°€: í•„í„° ì ìš© ë° ì¹´ë“œ ëª©ë¡ í‘œì‹œ
    
    
    // ğŸ¯ HTML íƒœê·¸ ì œê±° í•¨ìˆ˜
    function stripHTMLTags(text) {
      if (!text) return '';
      return text.replace(/<[^>]*>/g, '').trim();
    }
    
    // ğŸ¯ ìƒì„¸ ì •ë³´ ì—…ë°ì´íŠ¸
    
    
    // ë±ì— ì¶”ê°€ (user_card_id ë°©ì‹)
    async function addToDeck() {
try {
        if (!w.selectedCard) {
          alert('ì¹´ë“œë¥¼ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”.');
          return;
        }
        
        const card = w.selectedCard;
        const deckIndex = w.currentDeck || 0;
        const deck = w.playerData.decks[deckIndex];
        
        // user_card_id í™•ì¸
        if (!card.user_card_id) {
          alert('ì¹´ë“œ ì •ë³´ê°€ ë¶ˆì™„ì „í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì„ íƒí•´ì£¼ì„¸ìš”.');
          return;
        }
        
        // ì¤‘ë³µ í™•ì¸ (user_card_id ê¸°ì¤€)
        const isDuplicate = deck.some(item => {
          if (typeof item === 'object') {
            return item.user_card_id === card.user_card_id;
          }
          return false;
        });
        
        if (isDuplicate) {
          alert(`${card.name}ì€(ëŠ”) ì´ë¯¸ ë±ì— ìˆìŠµë‹ˆë‹¤.`);
          return;
        }
        
        // 10ì¥ ì œí•œ
        if (deck.length >= 10) {
          alert('ë±ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤. (ìµœëŒ€ 10ì¥)');
          return;
        }
        
      // ë±ì— ì¶”ê°€ (user_card_idì™€ ì¹´ë“œ ì •ë³´) - ì„ì‹œë¡œë§Œ
        let arr = w.playerData.decks[deckIndex] || [];
        let nextSlot = arr.findIndex(x => x == null);
        if (nextSlot === -1) nextSlot = Math.min(arr.length, 9);
        w.playerData.decks[deckIndex][nextSlot] = { user_card_id: card.user_card_id, card_slug: card.slug, rarity: card.rarity };

        
        // ì„œë²„ ì €ì¥ ì œê±° - ì €ì¥ ë²„íŠ¼ì„ ëˆŒëŸ¬ì•¼ë§Œ ì €ì¥ë¨
        // const saveSuccess = await saveDeckToServer(deckIndex, deck);
        // 
        // if (!saveSuccess) {
        //     // ì„œë²„ ì €ì¥ ì‹¤íŒ¨ ì‹œ ë¡œì»¬ì—ì„œë„ ì œê±°
        //     deck.pop();
        //     return;
        // }
        
        // UI ì—…ë°ì´íŠ¸
        refreshDeckUI();
        
        alert(`${card.name}ì„(ë¥¼) ë±ì— ì¶”ê°€í–ˆìŠµë‹ˆë‹¤!`);
        log(`added: ${card.name} to deck ${deckIndex}`);
        
      } catch (error) {
        console.error('Add to deck failed:', error);
        alert('ë± ì¶”ê°€ ì‹¤íŒ¨: ' + error.message);
      }
    }
    
    // ğŸ¯ ë± UI ìƒˆë¡œê³ ì¹¨ (ì´ë¯¸ì§€/ì´ë¦„ ë§¤í•‘ í¬í•¨) - ê°•ë ¥í•œ ì´ë²¤íŠ¸ ë°”ì¸ë”©
    // ìˆ˜ì •ëœ refreshDeckUI - ì¬ì‹œë„ ì¹´ìš´í„° ì¶”ê°€
    
    
    // ğŸ¯ ì œê±° ë²„íŠ¼ í™œì„±í™” í•¨ìˆ˜
    
    
    // ğŸ¯ ë±ì—ì„œ ì œê±° (ê¸°ì¡´ í•¨ìˆ˜ ìˆ˜ì • - íŒì—… ì œê±°, ì´ë¦„ ì œëŒ€ë¡œ í‘œì‹œ)
    async function removeFromDeck(cardSlug, slotIndex = -1) {
      try {
        const deckIndex = w.currentDeck || 0;
        const deck = w.playerData.decks[deckIndex];
        
        // ğŸ¯ ê°ì²´ ë°°ì—´ê³¼ ë¬¸ìì—´ ë°°ì—´ ëª¨ë‘ ì²˜ë¦¬
        let cardIndex = -1;
        
        if (w.selectedCard && w.selectedCard.user_card_id) {
          // user_card_idë¡œ ì°¾ê¸° (ìƒˆ ë°©ì‹)
          cardIndex = deck.findIndex(item => 
            typeof item === 'object' && item.user_card_id === w.selectedCard.user_card_id
          );
        }
        
        if (cardIndex === -1) {
          // ë¬¸ìì—´ë¡œ ì°¾ê¸° (ê¸°ì¡´ ë°©ì‹ í˜¸í™˜)
          cardIndex = deck.findIndex(item => {
            if (typeof item === 'string') return item === cardSlug;
            if (typeof item === 'object') return item.card_slug === cardSlug;
            return false;
          });
        }
        
        if (cardIndex > -1) {
          deck.splice(cardIndex, 1);
        }
        
        // ğŸ¯ ì„œë²„ì— ì €ì¥ (ê°•ì œ ëª¨ë“œ)
        const saveSuccess = await saveDeckToServer(deckIndex, deck);
        
        if (!saveSuccess) {
          // ì„œë²„ ì €ì¥ ì‹¤íŒ¨ ì‹œ ë³µì›
          if (cardIndex > -1) {
            deck.splice(cardIndex, 0, cardSlug);
          }
          return;
        }
        
        // UI ì—…ë°ì´íŠ¸
        refreshDeckUI();
        
        // ì„ íƒ í•´ì œ
        w.selectedCard = null;
        const name = d.getElementById('detailName');
        if (name) name.textContent = 'ì„ íƒëœ ì¹´ë“œ ì—†ìŒ';
        
        log(`removed from deck: ${cardSlug}`);
        
      } catch (error) {
        console.error('Remove from deck failed:', error);
        alert('ë± ì œê±° ì‹¤íŒ¨: ' + error.message);
      }
    }
    
    // ğŸ¯ ë± ë¹„ìš°ê¸°
    async function clearDeck() {
      try {
        const deckIndex = w.currentDeck || 0;
        const deck = w.playerData.decks[deckIndex];
        
        if (!deck || deck.length === 0) {
          alert('ë±ì´ ì´ë¯¸ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
          return;
        }
        
        if (!confirm(`ë± ${deckIndex + 1}ì˜ ëª¨ë“  ì¹´ë“œë¥¼ ì œê±°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
          return;
        }
        
        // ë°±ì—…
        const backupDeck = [...deck];
        
        // ë± ë°ì´í„° í´ë¦¬ì–´
        deck.length = 0;
        
        // ğŸ¯ ì„œë²„ì— ì €ì¥ (ê°•ì œ ëª¨ë“œ)
        const saveSuccess = await saveDeckToServer(deckIndex, deck);
        
        if (!saveSuccess) {
          // ì„œë²„ ì €ì¥ ì‹¤íŒ¨ ì‹œ ë³µì›
          deck.push(...backupDeck);
          return;
        }
        
        // UI ì—…ë°ì´íŠ¸
        refreshDeckUI();
        
        log(`cleared deck ${deckIndex}`);
        alert(`ë± ${deckIndex + 1}ì„(ë¥¼) ë¹„ì› ìŠµë‹ˆë‹¤.`);
        
      } catch (error) {
        console.error('Clear deck failed:', error);
        alert('ë± ë¹„ìš°ê¸° ì‹¤íŒ¨: ' + error.message);
      }
    }
    
    // ğŸ¯ ëŒ€í‘œë± ì„¤ì •
    async function setMainDeck() {
      try {
        const deckIndex = w.currentDeck || 0;
        const deck = w.playerData.decks[deckIndex];
        const deckSize = deck ? deck.length : 0;
        
        log(`setting main deck: deck ${deckIndex}, size: ${deckSize}`);
        
        // ğŸ¯ 10ì¥ ì²´í¬
        if (deckSize < 10) {
          alert(`ì¹´ë“œë¥¼ 10ì¥ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤. (í˜„ì¬: ${deckSize}/10)`);
          log(`main deck failed: only ${deckSize}/10 cards`);
          return;
        }
        
        // ëŒ€í‘œë± ì„¤ì •
        w.playerData.mainDeck = deckIndex;
        await saveMainDeckToServer(deckIndex);
        
        // ğŸ¯ ëŒ€í‘œë± ì‹œê°ì  í‘œì‹œ ì—…ë°ì´íŠ¸
        updateMainDeckIndicator();
        
        alert(`âœ… ë± ${deckIndex + 1}ì„(ë¥¼) ëŒ€í‘œë±ìœ¼ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤!`);
        log(`main deck set: deck ${deckIndex}`);
        
      } catch (error) {
        console.error('Set main deck failed:', error);
        alert('ëŒ€í‘œë± ì„¤ì • ì‹¤íŒ¨: ' + error.message);
      }
    }
    
    // ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ëŒ€í‘œë± í‘œì‹œ ì—…ë°ì´íŠ¸
    function updateMainDeckIndicator() {
      try {
        const mainDeckIndex = w.playerData.mainDeck;
        
        // ëª¨ë“  ë± íƒ­ì—ì„œ main-deck í´ë˜ìŠ¤ ì œê±°
        d.querySelectorAll('.deck-tab').forEach((tab, index) => {
          tab.classList.remove('main-deck');
          
          // ê¸°ì¡´ ë³„í‘œ ì œê±°
          const existingStar = tab.querySelector('.main-deck-star');
          if (existingStar) existingStar.remove();
          
          // ëŒ€í‘œë±ì— ë³„í‘œ ì¶”ê°€
          if (index === mainDeckIndex) {
            tab.classList.add('main-deck');
            
            const star = d.createElement('div');
            star.className = 'main-deck-star';
            star.style.cssText = `
              position: absolute;
              top: -5px;
              right: -5px;
              background: #ffd700;
              color: #000;
              border-radius: 50%;
              width: 20px;
              height: 20px;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 12px;
              font-weight: bold;
              box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            `;
            star.textContent = 'â˜…';
            
            tab.style.position = 'relative';
            tab.appendChild(star);
          }
        });
        
        log(`Updated main deck indicator: deck ${mainDeckIndex + 1}`);
        
      } catch (error) {
        console.error('Update main deck indicator failed:', error);
      }
    }
    
    // ğŸ¯ ë²„íŠ¼ ë°”ì¸ë”© (ì£¼ê¸°ì  í˜¸ì¶œ ì œê±°, í™”ë©´ ì „í™˜ ì‹œì—ë§Œ)
    
    // === BATTLE: build teams && start flow (5v5 ìˆ˜ì •) ===
    async function loadMainDeckFromServer() {
      try {
        const sb = window.__sb_singleton || window.supabase || window.sb;
        const { data:{ session } } = await sb.auth.getSession();
        if (!session?.user?.id) return null;
        const { data: profRows, error: profErr } = await sb
          .from('user_profiles')
          .select('main_deck_index')
          .eq('user_id', session.user.id)
          .limit(1);
        if (profErr) { console.log('user_profiles read error', profErr); return null; }
        const mdi = (profRows && profRows[0] && typeof profRows[0].main_deck_index === 'number')
          ? profRows[0].main_deck_index : null;
        if (mdi !== null && mdi >= 0 && mdi < 4) {
          w.playerData.mainDeck = mdi;
          updateMainDeckIndicator && updateMainDeckIndicator();
          return mdi;
        }
        return null;
      } catch (e) {
        console.log('loadMainDeckFromServer error', e);
        return null;
      }
    }

    async function saveMainDeckToServer(deckIndex){
      try{
        const sb = window.__sb_singleton || window.supabase || window.sb;
        const { data:{ session } } = await sb.auth.getSession();
        if (!session?.user?.id) throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
        const payload = { user_id: session.user.id, main_deck_index: deckIndex, updated_at: new Date().toISOString() };
        const { error } = await sb.from('user_profiles').upsert(payload, { onConflict: 'user_id' });
        if (error) throw error;
        return true;
      }catch(e){
        console.error('saveMainDeckToServer error', e);
        alert('ëŒ€í‘œë± ì €ì¥ ì‹¤íŒ¨: ' + (e.message||e));
        return false;
      }
    }

    async function getActiveDeckIndex() {
      const sb = window.__sb_singleton || window.supabase || window.sb;
      const { data:{ session } } = await sb.auth.getSession();
      if (!session?.user?.id) throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
      let mdi = w.playerData.mainDeck;
      if (typeof mdi !== 'number') {
        const tmp = await loadMainDeckFromServer();
        if (typeof tmp === 'number') mdi = tmp;
      }
      if (typeof mdi === 'number') return mdi;
      const { data: slots } = await sb.from('user_decks').select('deck_index,deck_slot').eq('user_id', session.user.id);
      const counts = [0,0,0,0]; (slots||[]).forEach(s=>{ if (s.deck_index>=0 && s.deck_index<4) counts[s.deck_index]++; });
      const full = counts.findIndex(c=>c>=10);
      return full!==-1 ? full : (w.currentDeck||0);
    }

    // ë‚´ ë± 10ì¥ ë¡œë“œ í•¨ìˆ˜ (ìƒˆ ê¸°ëŠ¥)
async function loadMyDeckAsCards() {
  try {
    const sb = window.__sb_singleton || window.supabase || window.sb;
    const { data: { session } } = await sb.auth.getSession();
    if (!session?.user?.id) throw new Error('ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
    
    // ëŒ€í‘œë± ì¸ë±ìŠ¤ ê°€ì ¸ì˜¤ê¸°
    const { data: profile } = await sb
      .from('user_profiles')
      .select('main_deck_index')
      .eq('user_id', session.user.id)
      .single();
    
    const deckIndex = profile?.main_deck_index ?? 0;
    
    // ë± ì¹´ë“œ ê°€ì ¸ì˜¤ê¸° (user_card_id ë°©ì‹ìœ¼ë¡œ ë³€ê²½)
    const { data: deckRows } = await sb
      .from('user_decks')
      .select('deck_slot, user_card_id, card_slug')
      .eq('user_id', session.user.id)
      .eq('deck_index', deckIndex)
      .order('deck_slot', { ascending: true });
    
    if (!deckRows || deckRows.length < 10) {
      console.warn('[loadMyDeckAsCards] ë±ì´ 10ì¥ ë¯¸ë§Œ:', deckRows?.length || 0);
      return [];
    }
    
    // user_card_idë¡œ user_cards + card_master ì¡°ì¸í•´ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ì¹´ë“œ ì»¬ë ‰ì…˜ê³¼ ë™ì¼í•œ ë°©ì‹)
    const userCardIds = deckRows.map(r => r.user_card_id).filter(Boolean);
    
    const { data: userCards } = await sb
      .from('user_cards')
      .select(`
        id, rarity, obtained_at,
        card_master:card_slug (
          slug, name, portrait_url, base_stats, skills,
          main_job, sub_job
        )
      `)
      .in('id', userCardIds)
      .eq('user_id', session.user.id);
    
    if (!userCards || userCards.length === 0) {
      console.warn('[loadMyDeckAsCards] user_cards ì¡°íšŒ ì‹¤íŒ¨');
      return [];
    }
    
    // user_card_id -> userCard ë§¤í•‘
    const userCardMap = {};
    userCards.forEach(uc => {
      userCardMap[uc.id] = uc;
    });
    
    // ì›ë³¸ ë± ìˆœì„œëŒ€ë¡œ ì¹´ë“œ ë°˜í™˜
    return deckRows.map(row => {
      const userCard = userCardMap[row.user_card_id];
      if (userCard && userCard.card_master) {
        const card = userCard.card_master;
        return {
          slug: row.card_slug,  // 'a_sc' í˜•íƒœ ìœ ì§€ (í¬ê·€ë„ í¬í•¨)
          name: card.name,
          portrait_url: card.portrait_url,
          base_stats: card.base_stats,
          skills: card.skills,
          main_job: card.main_job,
          sub_job: card.sub_job
        };
      }
      return null;
    }).filter(Boolean).slice(0, 10);
    
  } catch (error) {
    console.error('[loadMyDeckAsCards] Error:', error);
    return [];
  }
}

    // ì „íˆ¬ ì‹œì‘ í”Œë¡œìš° (ìƒˆ ê¸°ëŠ¥ ì¶”ê°€)
async function startBattleFlow() {
  try {
    console.log('[DEBUG] startBattleFlow ì‹œì‘');
    
    const sb = window.__sb_singleton || window.supabase || window.sb;
    if (!sb) {
      console.error('[ERROR] Supabase client not found');
      const iframe = document.getElementById('frame');
      if (iframe?.contentWindow?.showDeckWarningModal) {
        iframe.contentWindow.showDeckWarningModal();
      }
      return;
    }
    
    const { data: { session } } = await sb.auth.getSession();
        if (!session?.user) { 
          const iframe = document.getElementById('frame');
          if (iframe?.contentWindow?.showDeckWarningModal) {
            iframe.contentWindow.showDeckWarningModal();
          }
          return; 
        }
        
        // âœ… matchmake í˜¸ì¶œ (ìƒˆ ê¸°ëŠ¥)
        const { data: mm, error } = await sb.functions.invoke('matchmake', { body: {} });
        if (error) throw error;
        if (!mm?.ok) { 
          console.warn('[MM error]', mm); 
          throw new Error('ë§¤ì¹˜ë©”ì´í‚¹ ì‹¤íŒ¨');
        }
        
        // ì„œë²„-í´ë¼ ì‹œê°„ ì˜¤í”„ì…‹(ì¿¨ë‹¤ìš´ ëŒ€ë¹„) (ìƒˆ ê¸°ëŠ¥)
        window.__serverOffsetMs = Date.now() - Date.parse(mm?.server_now || new Date().toISOString());
        
        // VS í‘œì‹œì— í•„ìš”í•œ ì´ë¦„/ë©”íƒ€ ë³´ì¥
        const meName = mm?.names?.me || 'Me';
        const oppName = mm?.names?.opp || meName; // ë¬´ìƒëŒ€ â†’ ë¯¸ëŸ¬
        const matchId = mm?.match?.id || null;
        const seed = mm?.match?.seed || String(Date.now());
        const party = mm?.match?.party_size || 5;
        
        // ë©”ì¸í™”ë©´ ë‹‰ë„¤ì„ ì—…ë°ì´íŠ¸
        const gameDoc = f.contentWindow?.document;
        if (gameDoc) {
          const playerNameEl = gameDoc.getElementById('playerName');
          if (playerNameEl) {
            playerNameEl.textContent = meName;
          }
        }
        
        // 3) ë‚´ 10ì¥ / ìƒëŒ€ 10ì¥
        const my10 = await loadMyDeckAsCards();
        const opp10 = (mm.cards && mm.cards.length >= 10) ? mm.cards : my10;
        


       if (my10.length < 10) { 
  // ê²Œì„ íŒŒì¼ì˜ ëª¨ë‹¬ í‘œì‹œ í•¨ìˆ˜ í˜¸ì¶œ
  const iframe = document.getElementById('frame');
  if (iframe?.contentWindow?.showDeckWarningModal) {
    iframe.contentWindow.showDeckWarningModal();
  }
  return; 
}
        if (opp10.length < 10) { 
          const iframe = document.getElementById('frame');
          if (iframe?.contentWindow?.showDeckWarningModal) {
            iframe.contentWindow.showDeckWarningModal();
          }
          return; 
        }
        
        // 4) 5ì¥ ìƒ˜í”Œë§(ì¤‘ë³µ ì—†ìŒ, ì‹œë“œê³ ì •)
        const rngA = xorshift32(makeSeedFromString(seed + '|A'));
        const rngB = xorshift32(makeSeedFromString(seed + '|B'));
        const teamA = sampleK(my10, party, rngA);
        const teamB = sampleK(opp10, party, rngB);
        
        // ì „íˆ¬ ì „ ìºì‹œ ë³´ê°•
        const allSlugs = [...teamA, ...teamB].map(c => c.slug || c.name);
        const bases = [...new Set(allSlugs.map(s => CardUtils.parseSlug(s).base).filter(Boolean))];
        await CardUtils.ensureMasterCache(bases).catch(()=>{ /* ê¸°ì¡´ í”Œë¡œìš° ê³„ì† */ });
        
        // íŒ€A/B ì¤€ë¹„ - ê³„ì•½ì— ë§ëŠ” payload êµ¬ì„±
        const payload = {
          meta: { match_id: matchId, seed, partySize: party, meName, oppName, serverNow: mm?.server_now },
          teams: { A: teamA.map(c => {
            const fullSlug = c.slug || c.name;
            const parsed = CardUtils.parseSlug(fullSlug);
            return {
              slug: fullSlug,                                                           // ì „ì²´ ìŠ¬ëŸ¬ê·¸ (ë¡œê·¸/í‚¤ìš©)
              base_slug: parsed.base,                                                   // ì¡°íšŒìš© ë² ì´ìŠ¤
              suf: parsed.suf,                                                          // í¬ê·€ë„ suffix
              base_stats: c.base_stats || {},                                          // ì›ë³¸ (ë””ë²„ê¹…/í‘œì‹œìš©)
              stats: CardUtils.applyRarityStats(c.base_stats||{}, parsed.suf),        // âœ… í¬ê·€ë„ ë°˜ì˜ ìµœì¢… ìŠ¤íƒ¯ (ì „íˆ¬ëŠ” ì´ ê°’ë§Œ ì‚¬ìš©)
              name: c.name,
              portrait_url: c.portrait_url || '',
              skills: c.skills || {},
              main_job: c.main_job || '',                                             // âœ… ì¶”ê°€
              sub_job: c.sub_job || '',                                               // âœ… ì¶”ê°€
              affinity: c.base_stats?.affinity || ''                                  // âœ… ìµœìƒìœ„ë¡œ ì´ë™
            };
          }), B: teamB.map(c => {
            const fullSlug = c.slug || c.name;
            const parsed = CardUtils.parseSlug(fullSlug);
            return {
              slug: fullSlug,                                                           // ì „ì²´ ìŠ¬ëŸ¬ê·¸ (ë¡œê·¸/í‚¤ìš©)
              base_slug: parsed.base,                                                   // ì¡°íšŒìš© ë² ì´ìŠ¤
              suf: parsed.suf,                                                          // í¬ê·€ë„ suffix
              base_stats: c.base_stats || {},                                          // ì›ë³¸ (ë””ë²„ê¹…/í‘œì‹œìš©)
              stats: CardUtils.applyRarityStats(c.base_stats||{}, parsed.suf),        // âœ… í¬ê·€ë„ ë°˜ì˜ ìµœì¢… ìŠ¤íƒ¯ (ì „íˆ¬ëŠ” ì´ ê°’ë§Œ ì‚¬ìš©)
              name: c.name,
              portrait_url: c.portrait_url || '',
              skills: c.skills || {},
              main_job: c.main_job || '',                                             // âœ… ì¶”ê°€
              sub_job: c.sub_job || '',                                               // âœ… ì¶”ê°€
              affinity: c.base_stats?.affinity || ''                                  // âœ… ìµœìƒìœ„ë¡œ ì´ë™
            };
          }) }
        };
        
        window.__lastBattlePayload = payload; // ë””ë²„ê¹…ìš©

        // === ë””ë²„ê¹… ë¡œê·¸ ì¶”ê°€ (ê²Œì„íŒ€ ìš”ì²­) ===
        console.log('=== BATTLE PAYLOAD DEBUG ===');
        console.log('Team A first card:', JSON.stringify(payload.teams.A[0], null, 2));
        console.log('Team B first card:', JSON.stringify(payload.teams.B[0], null, 2));
        console.log('--- Skills Debug ---');
        console.log('Team A Skills:', payload.teams.A[0].skills);
        console.log('Team A Skills type:', typeof payload.teams.A[0].skills);
        console.log('Team A Skills keys:', Object.keys(payload.teams.A[0].skills || {}));
        console.log('--- Jobs Debug ---');
        console.log('Team A main_job:', payload.teams.A[0].main_job);
        console.log('Team A sub_job:', payload.teams.A[0].sub_job);
        console.log('--- Affinity Debug ---');
        console.log('Team A base_stats.affinity:', payload.teams.A[0].base_stats?.affinity);
        console.log('=========================');

// ê²Œì„ì— ì§ì ‘ ì„¤ì •
f.contentWindow.__battlePayload = payload;

// ê²Œì„ì— ë©”ì‹œì§€ ì „ì†¡ + í™”ë©´ ì „í™˜
f.contentWindow.postMessage({ type: 'START_BATTLE', payload }, '*');
        
        const w = f.contentWindow;
        if (w && w.showScreen) {
          w.showScreen('battleScreen');
        }
        
        log(`[MM] Match started: ${meName} vs ${oppName}`);
        
    } catch (error) {
  console.error('[startBattleFlow] Error:', error);
  
  // matchmake í•¨ìˆ˜ì—ì„œ ì‹¤ì œ ì‘ë‹µ ë‚´ìš©ì„ í™•ì¸í•´ë³´ì
  try {
    const sb = window.__sb_singleton || window.supabase || window.sb;
    const { data: { session } } = await sb.auth.getSession();
    
    const response = await fetch('https://ezuvoqehzojiqmzatzbf.supabase.co/functions/v1/matchmake', {
      method: 'POST',
      headers: { 
        'Authorization': 'Bearer ' + session.access_token,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({})
    });
    
    const responseText = await response.text();
    console.log('[DEBUG] Response status:', response.status);
    console.log('[DEBUG] Response text:', responseText);
    
    if (response.status === 429) {
      const data = JSON.parse(responseText);
      alert(`ì „íˆ¬ ì¿¨íƒ€ì„: ${data.message || 'ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”'}`);
      return;
    }
    
  } catch (fetchError) {
    console.log('[DEBUG] Fetch error:', fetchError);
  }
  
  // ë‹¤ë¥¸ ì—ëŸ¬ì¼ ë•Œ
  const iframe = document.getElementById('frame');
  if (iframe?.contentWindow?.showDeckWarningModal) {
    iframe.contentWindow.showDeckWarningModal();
  }
}
}
    // ì „íˆ¬ ê²°ê³¼ ìˆ˜ì‹  ë° ë³´ê³  (ë©±ë“± + í”„ë¡ íŠ¸ ì¤‘ë³µê°€ë“œ ë²„ì „)
    (function installBattleResultHandler(){
      // ì¤‘ë³µ ë¦¬ìŠ¤ë„ˆ ë°©ì§€
      if (window.__battleHandlerInstalled) return;
      window.__battleHandlerInstalled = true;

      // í”„ë¡ íŠ¸ ë‹¨ ì¤‘ë³µ ê°€ë“œ (match_id -> 'pending'|'done')
      const guard = new Map();
      const isPending = (id) => guard.get(id) === 'pending';
      const isDone    = (id) => guard.get(id) === 'done';
      const markPending = (id) => guard.set(id, 'pending');
      const markDone    = (id) => { guard.set(id, 'done'); setTimeout(()=>guard.delete(id), 60_000); };

      window.addEventListener('message', async function onBattleResult(e) {
        if (e?.data?.type !== 'BATTLE_RESULT') return;

        try {
          const payload = e.data?.payload || {};
          const match_id = payload.match_id;
          const winner   = payload.winner;
          if (!match_id || !winner) {
            console.warn('[BATTLE_RESULT] missing match_id/winner', payload);
            return;
          }

          // í”„ë¡ íŠ¸ ê°€ë“œ: ì²˜ë¦¬ ì¤‘/ì²˜ë¦¬ ì™„ë£Œëœ ë™ì¼ match_idëŠ” ë“œë¡­
          if (isPending(match_id)) { 
            console.log('[BATTLE_RESULT] duplicate while pending, dropped:', match_id); 
            return; 
          }
          if (isDone(match_id)) { 
            console.log('[BATTLE_RESULT] duplicate after done, dropped:', match_id); 
            return; 
          }
          markPending(match_id);

          // Supabase í´ë¼
          const sb = (typeof getSB === 'function') ? getSB() : window.__sb_singleton;
          if (!sb) throw new Error('Supabase client not found');

          // ì„œë²„(Edge)ë¡œ ë³´ê³  â€“ ì„œë²„ëŠ” apply_score_delta_idem + matches ì†Œë¹„ë¡œ ë©±ë“± ì²˜ë¦¬
          const rep = await sb.functions.invoke('report_battle', { body: { match_id, winner } });
          console.log('[REPORT_BATTLE]', rep.data || rep.error);

          // ì„±ê³µ â†’ ì™„ë£Œë¡œ ë§ˆí‚¹
          markDone(match_id);

          // HUD ì¦‰ì‹œ ê°±ì‹ 
          if (typeof refreshHeaderProfile === 'function') {
            await refreshHeaderProfile();
          }

          // ë¦¬ë”ë³´ë“œ ì—´ë ¤ìˆìœ¼ë©´ ì¬ì¡°íšŒ
          const iframe = document.getElementById('frame');
          if (window.__leaderboardOpen && typeof iframe?.contentWindow?.refreshLeaderboardCurrentTab === 'function') {
            await iframe.contentWindow.refreshLeaderboardCurrentTab();
          }

          try { typeof log === 'function' && log(`[REPORT] Battle result: ${winner}`); } catch(_){}

        } catch (error) {
          // ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ í—ˆìš©ì„ ìœ„í•´ ê°€ë“œ í•´ì œ
          const mid = e?.data?.payload?.match_id;
          if (mid) guard.delete(mid);

          console.warn('[BATTLE_RESULT handler]', error);
          alert('ì „íˆ¬ ê²°ê³¼ ë°˜ì˜ ì‹¤íŒ¨. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        }
      });
    })();


    function bindButtons() {
      const buttons = [
        { selector: '#mainScreen button, #mainScreen a', text: /ì „íˆ¬í•˜ê¸°/, action: async () => { await startBattleFlow(); } },
        { selector: '#mainScreen button, #mainScreen a', text: /ë±.*ì„¤ì •/, action: () => { 
          w.showScreen('deckScreen');  // âœ… í™”ë©´ ì „í™˜ë§Œ í˜¸ì¶œ
          // âŒ§ loadCards(), loadDeckFromServer(), refreshDeckUI() ì œê±° - ê²Œì„íŒŒì¼ì´ ìì²´ ì²˜ë¦¬
        }},
        { selector: '#mainScreen button, #mainScreen a', text: /ë‚´.*ì¹´ë“œ.*ë³´ê¸°/, action: () => { 
          w.showScreen('cardsScreen');  // âœ… í™”ë©´ ì „í™˜ë§Œ í˜¸ì¶œ
          // âŒ§ loadCards() ì œê±° - ê²Œì„íŒŒì¼ì´ ìì²´ ì²˜ë¦¬
        }},
        { selector: '#deckScreen button, #deckScreen a', text: /ë©”ì¸ìœ¼ë¡œ/, action: () => w.showScreen('mainScreen') },
        { selector: '#cardsScreen button, #cardsScreen a', text: /ë©”ì¸ìœ¼ë¡œ/, action: () => w.showScreen('mainScreen') },
        { selector: '#battleScreen button, #battleScreen a', text: /ë©”ì¸ìœ¼ë¡œ/, action: () => w.showScreen('mainScreen') },
        { selector: '#deckScreen button, #deckScreen a', text: /(ëŒ€í‘œ.*ë±|ëŒ€í‘œ.*ì„¤ì •)/, action: setMainDeck },
        { selector: '#deckScreen button, #deckScreen a', text: /(ë±.*ë¹„ìš°ê¸°|ë¹„ìš°ê¸°|Clear)/, action: clearDeck }
      ];
      
      buttons.forEach(({ selector, text, action }) => {
        d.querySelectorAll(selector).forEach(btn => {
          if (text.test(btn.textContent || '') && !btn.__bound) {
            btn.__bound = true;
            btn.addEventListener('click', (e) => {
              e.preventDefault();
              action();
            }, true);
          }
        });
      });
      
      // ğŸ¯ ë± íƒ­ ë°”ì¸ë”© (ëŒ€í‘œë± í‘œì‹œ ì—…ë°ì´íŠ¸ í¬í•¨)
      d.querySelectorAll('.deck-tab').forEach((tab, index) => {
        if (!tab.__deck_bound) {
          tab.__deck_bound = true;
          tab.addEventListener('click', () => {
            w.currentDeck = index;
            d.querySelectorAll('.deck-tab').forEach((t, i) => t.classList.toggle('active', i === index));
            refreshDeckUI();
            updateMainDeckIndicator(); // ğŸ¯ ë± íƒ­ ì „í™˜ ì‹œ ëŒ€í‘œë± í‘œì‹œ ì—…ë°ì´íŠ¸
          });
        }
      });
    }
    
    // ğŸ¯ ìƒˆë¡œ ì¶”ê°€: ê²Œì„ íŒŒì¼ì˜ ê°€ì±  ë²„íŠ¼ í™œì„±í™”
    function enableGachaInGame() {
      try {
        // ê²Œì„ íŒŒì¼ì—ì„œ ë¹„í™œì„±í™”ëœ ê°€ì±  ë²„íŠ¼ë“¤ì„ ë‹¤ì‹œ í™œì„±í™”
        const gachaButtons = d.querySelectorAll('button[id*="draw"], button[id*="card"], button[id*="gacha"]');
        gachaButtons.forEach(btn => {
          if (/ì¹´ë“œ.*ë½‘ê¸°|draw|ê°€ì± /i.test(btn.textContent || '')) {
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.title = '';
            log(`âœ… Enabled gacha button: ${btn.textContent}`);
          }
        });
        
        // íŠ¹ì • IDë¡œ ì°¾ê¸°
        const drawBtn = d.getElementById('drawCardBtn');
        if (drawBtn) {
          drawBtn.disabled = false;
          drawBtn.style.opacity = '1';
          drawBtn.title = '';
          log('âœ… Enabled main draw button');
        }
        
      } catch (error) {
        console.error('Enable gacha in game failed:', error);
      }
    }
    
    
    
    // ğŸ¯ ë‹¨ì¼ ìŠ¬ë¡¯ ì´ë²¤íŠ¸ ë°”ì¸ë”©
    
    
    // ì´ˆê¸° ì„¤ì •
    let activeScreen = d.querySelector('.screen.active');
    if (!activeScreen) {
      activeScreen = d.getElementById('mainScreen') || d.querySelector('.screen');
      if (activeScreen) activeScreen.classList.add('active');
    }
    
    
    
    // ğŸ¯ ê²Œì„ íŒŒì¼ì˜ ê°€ì±  ë²„íŠ¼ í™œì„±í™”
    setTimeout(enableGachaInGame, 500);
    
    // ğŸ¯ ì´ˆê¸° ëŒ€í‘œë± í‘œì‹œ (ë± í™”ë©´ ì§„ì… ì‹œ)
    setTimeout(updateMainDeckIndicator, 1000);
    
    // ğŸ¯ ì¦‰ì‹œ í•¨ìˆ˜ ì£¼ì… (HTML íŒŒì‹± ì „ì— ì‹¤í–‰)
    function injectMissingGameFunctions() {
      try {
        // [ì œê±°] setSpeed ì˜¤ë²„ë¼ì´ë“œ ì œê±° - ê²Œì„ì˜ ê¸°ë³¸ setSpeed ì‚¬ìš©

        // filterLogs í•¨ìˆ˜ ì œëŒ€ë¡œ êµ¬í˜„ (log-line í´ë˜ìŠ¤ ê¸°ì¤€)
        w.filterLogs = function(filterType) {
          try {
           // ì „ì—­ í•„í„° ë³€ìˆ˜ ì„¤ì • ì¶”ê°€!
        w.GLOBAL_LOG_FILTER = filterType;
            // ëª¨ë“  í•„í„° íƒ­ì—ì„œ active í´ë˜ìŠ¤ ì œê±°
            d.querySelectorAll('.log-filter-tab').forEach(tab => tab.classList.remove('active'));
            
            // í´ë¦­ëœ íƒ­ì— active í´ë˜ìŠ¤ ì¶”ê°€
            const filterNames = { 'all': 'ì „ì²´', 'damage': 'í”¼í•´', 'heal': 'ì¹˜ìœ ', 'buff': 'ë²„í”„', 'status': 'ìƒíƒœ', 'turn': 'í„´' };
            const clickedTab = [...d.querySelectorAll('.log-filter-tab')]
              .find(tab => tab.textContent.includes(filterNames[filterType] || filterType));
            if (clickedTab) clickedTab.classList.add('active');
            
            // log-line í´ë˜ìŠ¤ ê¸°ì¤€ìœ¼ë¡œ í•„í„°ë§
            const logLines = d.querySelectorAll('.log-line, .log-entry');
            logLines.forEach(line => {
              const text = (line.textContent || '').toLowerCase();
              let shouldShow = filterType === 'all';
              
              // í´ë˜ìŠ¤ ê¸°ì¤€ í•„í„°ë§
              if (!shouldShow) {
                if (filterType === 'damage' && (line.classList.contains('damage') || text.includes('í”¼í•´') || text.includes('ê³µê²©'))) shouldShow = true;
                if (filterType === 'heal' && (line.classList.contains('heal') || text.includes('ì¹˜ìœ ') || text.includes('íšŒë³µ'))) shouldShow = true;
                if (filterType === 'buff' && (line.classList.contains('buff') || text.includes('ë²„í”„') || text.includes('â†‘'))) shouldShow = true;
                if (filterType === 'status' && (line.classList.contains('status') || text.includes('ìƒíƒœ') || text.includes('ê¸°ì ˆ'))) shouldShow = true;
                if (filterType === 'turn' && (line.classList.contains('turn') || text.includes('í„´') || text.includes('â€”'))) shouldShow = true;
              }
              
              line.style.display = shouldShow ? '' : 'none';
              line.classList.toggle('hidden', !shouldShow);
            });
            
            log(`Log filter set to: ${filterType}`);
          } catch (error) {
            console.error('filterLogs error:', error);
          }
        };

        log('âœ… Core game functions injected immediately');
        
      } catch (error) {
        console.error('Immediate function injection failed:', error);
      }
    }

    // ğŸ¯ ì¦‰ì‹œ í•¨ìˆ˜ ì£¼ì… ì‹¤í–‰
    injectMissingGameFunctions();

    // B-2: ë°±ì›Œë“œ í˜¸í™˜ì„±ì„ ìœ„í•œ no-op í•¨ìˆ˜ë“¤
    window.filterAndDisplayCards ||= function(){ /* no-op - ê²Œì„íŒŒì¼ì´ ìì²´ ë Œë” */ };
    window.refreshDeckUI = function() {
  // no-op - ê²Œì„ íŒŒì¼ì´ ëª¨ë“  UI ë Œë”ë§ ë‹´ë‹¹
  try {
    const iframe = document.getElementById('frame');
    const w = iframe?.contentWindow;
    if (w && typeof w.refreshDeckSlots === 'function') {
      w.refreshDeckSlots(); // ê²Œì„ íŒŒì¼ì˜ ì‹¤ì œ ë Œë”ë§ í•¨ìˆ˜ í˜¸ì¶œ
    }
  } catch(e) {
    console.warn('[Launcher refreshDeckUI]', e);
  }
};

    // B-3: ê°€ì±  ì—°ì¶œ shim ì¶”ê°€ (showCardReveal â†’ showDrawReveal ë¸Œë¦¿ì§•)
    window.showCardReveal ||= function(card, rarity){
      try{
        const f = document.getElementById('frame'); 
        const w = f && f.contentWindow;
        if (w && typeof w.showDrawReveal === 'function') {
          return w.showDrawReveal(card, rarity);   // âœ… ê²Œì„íŒŒì¼ì˜ ì‹¤ì œ ì—°ì¶œ í˜¸ì¶œ
        }
        // í´ë°±: ë©”ì‹œì§€ë¡œ ìœ„ì„
        w && w.postMessage({ type:'REVEAL_CARD', payload:{ card, rarity } }, '*');
      }catch(e){
        console.warn('[Launcher] showCardReveal fallback', e);
        alert(`${card?.name||'ì¹´ë“œ'} (${rarity}) íšë“`); // ìµœí›„ í´ë°±
      }
    };

    // B-4: ë™ê¸°í™” ì‹ í˜¸ ìˆ˜ì‹  ë¡œê·¸ (ë””ë²„ê¹…ìš©)
    window.addEventListener('message', e=>{
      if(e?.data?.type === 'DECK_READY')  console.log('[LAUNCHER] DECK_READY received');
      if(e?.data?.type === 'CARDS_READY') console.log('[LAUNCHER] CARDS_READY received');
    });

    // ğŸ¯ í•¨ìˆ˜ë“¤ì„ ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ
    w.loadDeckFromServer = loadDeckFromServer;
    w.saveDeckToServer = saveDeckToServer;
    w.refreshDeckUI = refreshDeckUI;
    w.loadCards = loadCards;
    w.removeFromDeck = removeFromDeck;
    w.loadMainDeckFromServer = loadMainDeckFromServer;
    w.startBattleFlow = startBattleFlow; // ì „íˆ¬ ì‹œì‘ í•¨ìˆ˜ë„ ë…¸ì¶œ
    
    // ğŸ¯ ê²Œì„ì—ì„œ ì°¸ì¡°í•˜ëŠ” í•¨ìˆ˜ë“¤ ì œê³µ
    w.backToMain = () => w.showScreen('mainScreen');
    w.showMain = () => w.showScreen('mainScreen');
    w.displayHome = () => w.showScreen('mainScreen');
    
    log('âœ… optimized launcher ready (5v5 battle mode FINAL)');
  });

  log('load ' + f.src);

  // íˆ´ë°”
  document.getElementById('btn-main').onclick = () => {
    try { 
      f.contentWindow.showScreen && f.contentWindow.showScreen('mainScreen'); 
    } catch(e) {
      console.error('Main button error:', e);
    }
  };
  
  document.getElementById('btn-clear-session').onclick = () => {
    try {
      Object.keys(localStorage).forEach(k => { 
        if (k.includes('sb-') && k.includes('auth-token')) localStorage.removeItem(k); 
      });
      alert('ì„¸ì…˜ ì‚­ì œë¨');
    } catch(e) {
      console.error('Clear session error:', e);
    }
  };
}
)();
  </script>

  <!-- ===== Auth Gate ===== -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    #authGate {
      position: fixed; inset: 0; background: rgba(10,12,20,.92); color:#fff; z-index: 100000;
      display: flex; align-items: center; justify-content: center; padding: 24px;
      font-family: system-ui, Segoe UI, Roboto, Malgun Gothic, sans-serif;
    }
    #authGate.hidden {
      display: none !important;
    }
    #authBox {
      width: 360px; background: #141826; border: 1px solid #2d3553; border-radius: 12px; padding: 18px;
      box-shadow: 0 10px 40px rgba(0,0,0,.45);
    }
    #authBox h2 { margin: 0 0 12px; font-size: 18px; }
    #authBox input {
      width: 100%; padding: 10px 12px; margin: 6px 0 10px;
      background:#0e1120; border:1px solid #2a3352; border-radius:8px; color:#fff;
    }
    #authBox button {
      width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #4c5bd1; background:#5e59d6; color:#fff; cursor:pointer;
    }
    #authBox .row { display:flex; gap:10px; }
    #authErr { color:#ff9494; font-size:12px; min-height:16px; margin:6px 0 0; }
  </style>

  <div id="authGate">
    <div id="authBox">
      <h2>ë¡œê·¸ì¸ / íšŒì›ê°€ì…</h2>
      <input id="agEmail" type="email" placeholder="ì´ë©”ì¼" autocomplete="email" />
      <input id="agPw" type="password" placeholder="ë¹„ë°€ë²ˆí˜¸(6ì ì´ìƒ)" autocomplete="current-password" />
      <div class="row">
        <button id="agLogin">ë¡œê·¸ì¸</button>
        <button id="agSignup" style="background:#2f334a;border-color:#424a88">íšŒì›ê°€ì…</button>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="agLogout" style="background:#30354d;border-color:#4b517a">ë¡œê·¸ì•„ì›ƒ</button>
        <button id="agClear"  style="background:#30354d;border-color:#4b517a">í† í°ì‚­ì œ</button>
      </div>
      <div id="authErr"></div>
    </div>
  </div>

  <script>
  // waitForIframeReady í•¨ìˆ˜ ì •ì˜
  async function waitForIframeReady(maxWaitMs = 8000) {
    const f = document.getElementById('frame');
    if (!f) return false;
    const start = Date.now();
    return new Promise((resolve) => {
      function check() {
        try {
          const w = f.contentWindow;
          const d = w && w.document;
          if (w && d && (d.readyState === 'interactive' || d.readyState === 'complete')) {
            return resolve(true);
          }
        } catch(_) {}
        if (Date.now() - start > maxWaitMs) return resolve(false);
        setTimeout(check, 100);
      }
      f.addEventListener('load', () => setTimeout(check, 0), { once: true });
      check();
    });
  }
  
  (function(){
    const SUPABASE_URL = 'https://ezuvoqehzojiqmzatzbf.supabase.co';
    const SUPABASE_ANON= 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImV6dXZvcWVoem9qaXFtemF0emJmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwMDM4ODQsImV4cCI6MjA3MDU3OTg4NH0.4B33BI-WOgoeQHvQ4XBTNwwCCfvQiuVMWRpnOOOHrjw';
    const sb = (window.__sb_singleton ||= supabase.createClient(SUPABASE_URL, SUPABASE_ANON));

    const gate   = document.getElementById('authGate');
    const email  = document.getElementById('agEmail');
    const pw     = document.getElementById('agPw');
    const btnLo  = document.getElementById('agLogin');
    const btnSu  = document.getElementById('agSignup');
    const btnLg  = document.getElementById('agLogout');
    const btnCl  = document.getElementById('agClear');
    const errBox = document.getElementById('authErr');

    const showGate = () => { gate.style.display = 'flex'; gate.classList.remove('hidden'); };
    const hideGate = () => { gate.style.display = 'none'; gate.classList.add('hidden'); };
    const setErr   = (m='') => errBox.textContent = m;

    function goMain() {
      try { 
        document.getElementById('frame').contentWindow.showScreen('mainScreen'); 
      } catch(e) {
        console.error('Go main error:', e);
      }
    }

    // ë‹¨ì¼ refreshHeaderProfile í•¨ìˆ˜ ì •ì˜
    async function refreshHeaderProfile() {
      try {
        const sb = (typeof getSB==='function') ? getSB() : (window.__sb_singleton||null);
        if (!sb) return;

        const { data:{ session } } = await sb.auth.getSession();
        const uid = session?.user?.id; 
        if (!uid) return;
        
        const { data: prof } = await sb
          .from('user_profiles')
          .select('display_name, pvp_score')
          .eq('user_id', uid)
          .maybeSingle();
          
        if (!prof) return;

        // ì´ë¦„/ì ìˆ˜ ê³„ì‚° (í•œ ë²ˆë§Œ)
        const name  = prof.display_name || 'Player';
        const score = (typeof prof.pvp_score === 'number') ? prof.pvp_score : 1000;

        // --- HUD ì¤‘ë³µ ë°©ì§€ ---
        const prev = window.__HUD_LAST || {};
        if (prev.name === name && prev.score === score) return;
        window.__HUD_LAST = { name, score };

        // HUD / DOM ê°±ì‹ 
        const iframe  = document.getElementById('frame');
        const gameDoc = iframe?.contentWindow?.document;
        if (gameDoc) {
          const playerNameEl  = gameDoc.getElementById('playerName');
          if (playerNameEl)  playerNameEl.textContent  = name;
          const playerScoreEl = gameDoc.getElementById('playerScore');
          if (playerScoreEl) playerScoreEl.textContent = String(score);
        }
      } catch (e) {
        console.warn('[refreshHeaderProfile]', e);
      }
    }

    // ë‹¨ì¼ syncSession í•¨ìˆ˜ ì •ì˜
    async function syncSession() {
      try {
        const { data:{ session } } = await sb.auth.getSession();
        if (session) { 
          hideGate(); 
          goMain(); 
          
          // iframe ì¤€ë¹„ ëŒ€ê¸°
          await waitForIframeReady();
        } else { 
          showGate(); 
        }
      } catch(e) {
        console.error('syncSession error:', e);
        showGate();
      }
    }

    // íšŒì›ê°€ì…
    btnSu.onclick = async () => {
      setErr('');
      try{
        const em = (email.value||'').trim();
        const pv = (pw.value||'');
        if (!/^[^@]+@[^@]+\.[^@]+$/.test(em)) { setErr('ì´ë©”ì¼ í˜•ì‹ ì˜¤ë¥˜'); return; }
        if (pv.length < 6) { setErr('ë¹„ë°€ë²ˆí˜¸ëŠ” 6ì ì´ìƒ'); return; }

        const { error } = await sb.auth.signUp({ email: em, password: pv });
        if (error) { setErr(error.message); return; }

        await sb.auth.signOut();
        alert('íšŒì›ê°€ì… ì™„ë£Œ! ë¡œê·¸ì¸ í•´ì£¼ì„¸ìš”.');
        showGate();
      } catch(e) { 
        setErr('íšŒì›ê°€ì… ì˜¤ë¥˜'); 
      }
    };

    // ë¡œê·¸ì¸
    btnLo.onclick = async () => {
      setErr('');
      try{
        const em = (email.value||'').trim();
        const pv = (pw.value||'');
        const pre = await sb.auth.getSession();
        if(pre.data?.session?.user){ hideGate(); return; }
        const { error } = await sb.auth.signInWithPassword({ email: em, password: pv });
        if (error) { setErr(error.message || 'ë¡œê·¸ì¸ ì˜¤ë¥˜'); return; }
        await syncSession();
      } catch(e) { 
        setErr('ë¡œê·¸ì¸ ì˜¤ë¥˜'); 
      }
    };

    // ë¡œê·¸ì•„ì›ƒ
    btnLg.onclick = async () => {
      await sb.auth.signOut();
      showGate();
    };

    // í† í° ì‚­ì œ
    btnCl.onclick = () => {
      try{
        Object.keys(localStorage).forEach(k => { if (k.includes('supabase') && k.endsWith('auth-token')) localStorage.removeItem(k); });
        showGate(); alert('ë¡œì»¬ í† í° ì‚­ì œë¨.');
      } catch(e) { console.warn(e); }
    };

    // ì´ˆê¸° ìƒíƒœ - ë¡œê·¸ì¸ì°½ ê°•ì œ í‘œì‹œ
    showGate();
    syncSession();
    sb.auth.onAuthStateChange(() => { syncSession(); });
  })();
  </script>

  <script>
  // === Auth boot: ensure gate follows real session state ===
  (function bootAuthGate(retry){
    retry = retry || 0;
    try{
      var sb = (typeof getSB === 'function') ? getSB() : (window.__sb_singleton || null);
      if(!sb){
        if(retry < 20) return setTimeout(function(){ bootAuthGate(retry+1); }, 250);
        return;
      }
      sb.auth.getSession().then(function(res){
        var session = res && res.data && res.data.session;
        var gate = document.getElementById('authGate');
        if (session && session.user) {
          if (gate) gate.style.display = 'none';
          (async()=>{ 
            try{ 
              await waitForIframeReady(); 
              if (typeof refreshHeaderProfile === 'function') refreshHeaderProfile(); 
            } catch(_){} 
          })();
        } else {
          if (gate) gate.style.display = 'flex';
        }
      });
      sb.auth.onAuthStateChange(function(event){
        var gate = document.getElementById('authGate');
        if (event === 'SIGNED_IN') {
          if (gate) gate.style.display = 'none';
          (async()=>{ 
            try{ 
              await waitForIframeReady(); 
              if (typeof refreshHeaderProfile === 'function') refreshHeaderProfile(); 
            } catch(_){} 
          })();
        } else if (event === 'SIGNED_OUT') {
          if (gate) gate.style.display = 'flex';
        }
      });
    }catch(e){
      console.warn('[bootAuthGate]', e);
      if(retry < 20) setTimeout(function(){ bootAuthGate(retry+1); }, 500);
    }
  })(0);
  </script>

  <!-- AUTH STABILIZER PATCH -->
  <script>
  (function(){
    if (window.__AUTH_STABILIZER_APPLIED__) return;
    window.__AUTH_STABILIZER_APPLIED__ = true;

    const sb = (function(){
      if (window.__sb_singleton) return window.__sb_singleton;
      if (window.sb && window.sb.auth && window.sb.from) return window.sb;
      if (window.supabase && typeof window.supabase.createClient !== 'undefined') {
        try {
          const url = window.SUPABASE_URL || window.SB_URL || window.SUPABASE_PROJECT_URL;
          const anon= window.SUPABASE_ANON || window.SB_ANON || window.SUPABASE_ANON_KEY;
          if (url && anon) {
            const c = window.supabase.createClient(url, anon);
            window.__sb_singleton = c;
            return c;
          }
        } catch(_) {}
      }
      return null;
    })();

    if (!sb || !sb.auth) {
      console.warn("[AuthStabilizer] No Supabase client found; patch is inert.");
      return;
    }

    const byId = (id) => document.getElementById(id);
    const gate   = byId('authGate');
    const email  = byId('agEmail');
    const pw     = byId('agPw');
    const btnLo  = byId('agLogin');
    const btnSu  = byId('agSignup');
    const btnLg  = byId('agLogout');
    const btnCl  = byId('agClear');
    const errBox = byId('authErr');
    const iframe = byId('frame');

    const setErr = (m='') => { if (errBox) errBox.textContent = m; };
    const showGate = () => { if (gate) gate.style.display = 'flex'; };
    const hideGate = () => { if (gate) gate.style.display = 'none'; };

    function waitForIframeReady(timeoutMs = 1200) {
      return new Promise((resolve) => {
        const start = Date.now();
        (function tick(){
          if (!iframe || !iframe.contentWindow) return resolve();
          try {
            const doc = iframe.contentWindow.document;
            if (!doc || doc.readyState !== 'complete') {
              if (Date.now() - start > timeoutMs) return resolve();
              return setTimeout(tick, 60);
            }
          } catch(_) {}
          resolve();
        })();
      });
    }

    async function applySessionUI() {
      try {
        const { data: { session } } = await sb.auth.getSession();
        if (session && session.user) {
          hideGate();
          try {
            await waitForIframeReady();
            if (typeof window.refreshHeaderProfile === 'function') window.refreshHeaderProfile();
            iframe && iframe.contentWindow && iframe.contentWindow.postMessage({ type: 'LOGIN_COMPLETE' }, '*');
          } catch(_) {}
        } else {
          showGate();
        }
      } catch(_) {
        showGate();
      }
    }

    if (!window.__AUTH_STABILIZER_BOUND__) {
      window.__AUTH_STABILIZER_BOUND__ = true;
      sb.auth.onAuthStateChange((_event, _session) => {
        applySessionUI();
      });
    }

    applySessionUI();

    const onceAsync = (fn) => async (...args) => {
      if (fn.__busy) return;
      try {
        fn.__busy = true;
        return await fn(...args);
      } finally {
        fn.__busy = false;
      }
    };

    async function purgeTokens() {
      try { await sb.auth.signOut(); } catch(_) {}
      try {
        Object.keys(localStorage).forEach(k => {
          const lk = (k||"") + "";
          if ((lk.includes('supabase') || lk.includes('sb-') || lk.includes('auth')) && lk.includes('token')) {
            localStorage.removeItem(k);
          }
        });
      } catch(_) {}
    }

    async function doLogin() {
      setErr('');
      if (!btnLo) return;
      btnLo.disabled = true;
      const oldText = btnLo.textContent;
      btnLo.textContent = 'ë¡œê·¸ì¸ ì¤‘...';

      try {
        const em = (email && (email.value||'').trim()) || '';
        const pv = (pw && (pw.value||'')) || '';

        if (!/^[^@]+@[^@]+\.[^@]+$/.test(em)) { setErr('ì´ë©”ì¼ í˜•ì‹ ì˜¤ë¥˜'); return; }
        if (pv.length < 6) { setErr('ë¹„ë°€ë²ˆí˜¸ëŠ” 6ì ì´ìƒ'); return; }

        await purgeTokens();

        const { error } = await sb.auth.signInWithPassword({ email: em, password: pv });
        if (error) { setErr(error.message || 'ë¡œê·¸ì¸ ì˜¤ë¥˜'); return; }

        await applySessionUI();
      } catch(e) {
        setErr('ë¡œê·¸ì¸ ì˜¤ë¥˜');
      } finally {
        btnLo.textContent = oldText;
        btnLo.disabled = false;
      }
    }

    async function doLogout() {
      await purgeTokens();
      await applySessionUI();
    }
    async function doClear() {
      await purgeTokens();
      showGate();
      try { alert('ë¡œì»¬ í† í° ì‚­ì œë¨.'); } catch(_) {}
    }

    if (btnLo)  btnLo.onclick = onceAsync(doLogin);
    if (btnLg)  btnLg.onclick = onceAsync(doLogout);
    if (btnCl)  btnCl.onclick = onceAsync(doClear);

    [email, pw].forEach(el => {
      if (!el) return;
      el.addEventListener('keydown', (e)=>{
        if (e.key === 'Enter' && btnLo && !btnLo.disabled) {
          btnLo.click();
        }
      });
    });

    console.log("[AuthStabilizer] Patch applied.");
  })();
  </script>
<script>
(function(){
  const btn = document.getElementById('btn-logout');
  if (!btn) return;

  // ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€
  function setLogoutVisible(v){
    if (!btn) return;
    btn.classList.toggle('hidden', !v);
  }

  // ì´ˆê¹ƒê°’: ìˆ¨ê¹€
  setLogoutVisible(false);

  // Supabase ì„¸ì…˜ ìƒíƒœì— ë”°ë¼ ë²„íŠ¼ í‘œì‹œ
  const sb = window.__sb_singleton;
  async function syncVisibility(){
    try{
      const { data:{ session } } = await sb.auth.getSession();
      setLogoutVisible(!!session?.user);
    }catch(_){}
  }
  syncVisibility();
  sb.auth.onAuthStateChange((_e, session)=>{
    setLogoutVisible(!!session?.user);
  });

  // í´ë¦­ ì‹œ: ë¡œê·¸ì•„ì›ƒ + Auth Gate ë³´ì—¬ì£¼ê¸° + ê²Œì„ í™”ë©´ ë©”ì¸ìœ¼ë¡œ ë³µê·€(ìˆìœ¼ë©´)
  btn.addEventListener('click', async ()=>{
    try{
      await sb.auth.signOut();
      // (ë³´ìˆ˜ì ) ë¡œì»¬ í† í° ì¼ë¶€ ì •ë¦¬ â€” ê¸°ì¡´ ì½”ë“œì™€ ì¶©ëŒ ì—†ìŒ
      try {
        Object.keys(localStorage).forEach(k=>{
          const s = String(k);
          if (s.includes('supabase') || (s.includes('sb-') && s.includes('auth'))) {
            localStorage.removeItem(k);
          }
        });
      } catch(_){}

      // Auth Gate ë‹¤ì‹œ í‘œì‹œ (ëŸ°ì²˜ì— ì´ë¯¸ ì¡´ì¬)
      const gate = document.getElementById('authGate');
      if (gate){
        gate.style.display = 'flex';
        gate.classList.remove('hidden');
      }

      // ê²Œì„ iframeì´ ì¼œì ¸ ìˆìœ¼ë©´ ë©”ì¸ í™”ë©´ìœ¼ë¡œ ëŒë ¤ë†“ê¸°(ì„ íƒ)
      const f = document.getElementById('frame');
      try{
        f?.contentWindow?.showScreen?.('mainScreen');  // ê²Œì„ íŒŒì¼ ë‚´ ë„¤ë¹„ê²Œì´ì…˜ í•¨ìˆ˜:contentReference[oaicite:2]{index=2}
      }catch(_){}
      
      setLogoutVisible(false);
      alert('ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤.');
    }catch(e){
      console.warn('logout error', e);
      alert('ë¡œê·¸ì•„ì›ƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }
  });
})();
</script>
<script>
(function(){
  const sb  = window.__sb_singleton;
  const btn = document.getElementById('btn-logout');

  function show(v){ btn.style.display = v ? '' : 'none'; }

  // ë¡œê·¸ì¸ ìƒíƒœì—ë§Œ ë³´ì´ê¸°
  (async ()=>{ try{
    const { data:{ session } } = await sb.auth.getSession();
    show(!!session?.user);
  }catch(_){} })();

  sb.auth.onAuthStateChange((_e, session)=> show(!!session?.user));

  // í´ë¦­ â†’ ë¡œê·¸ì•„ì›ƒ + Auth Gate ë³´ê¸° + ê²Œì„ ë©”ì¸ìœ¼ë¡œ
  btn.addEventListener('click', async ()=>{
    try{
      await sb.auth.signOut();
      // (ë³´ìˆ˜ì ) ë¡œì»¬ í† í° ì¼ë¶€ ì œê±°
      try {
        Object.keys(localStorage).forEach(k=>{
          const s=String(k);
          if (s.includes('supabase') || (s.includes('sb-') && s.includes('auth'))) localStorage.removeItem(k);
        });
      }catch(_){}
      document.getElementById('authGate')?.classList?.remove('hidden');
      const gate = document.getElementById('authGate'); if (gate) gate.style.display='flex';
      document.getElementById('frame')?.contentWindow?.showScreen?.('mainScreen');
      show(false);
      alert('ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤.');
    }catch(e){
      console.warn('logout error', e); alert('ë¡œê·¸ì•„ì›ƒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    }
  });
})();
</script>


</body>
</html>